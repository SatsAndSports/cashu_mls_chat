<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MDK Ecash Web Client</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: Arial, sans-serif;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        #header {
            background: #0066cc;
            color: white;
            padding: 15px 20px;
            font-size: 1.2em;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        #menu-toggle {
            display: none;
            background: none;
            border: none;
            color: white;
            font-size: 1.5em;
            cursor: pointer;
            padding: 5px 10px;
            margin: 0;
        }
        #main {
            display: flex;
            flex: 1;
            overflow: hidden;
        }
        #sidebar {
            width: 250px;
            background: #f5f5f5;
            border-right: 1px solid #ddd;
            overflow-y: auto;
        }
        .nav-item {
            padding: 15px 20px;
            cursor: pointer;
            border-bottom: 1px solid #ddd;
            transition: background 0.2s;
        }
        .nav-item:hover {
            background: #e6e6e6;
        }
        .nav-item.active {
            background: white;
            border-left: 3px solid #0066cc;
            padding-left: 17px;
        }
        .wallet-balance {
            font-size: 0.85em;
            color: #666;
            margin-top: 4px;
            font-weight: bold;
        }
        @keyframes balanceIncrease {
            0% { color: #28a745; transform: scale(1); }
            50% { color: #28a745; transform: scale(1.15); }
            100% { color: #666; transform: scale(1); }
        }
        @keyframes balanceDecrease {
            0% { color: #dc3545; transform: scale(1); }
            50% { color: #dc3545; transform: scale(1.15); }
            100% { color: #666; transform: scale(1); }
        }
        .balance-increase {
            animation: balanceIncrease 0.6s ease-out;
        }
        .balance-decrease {
            animation: balanceDecrease 0.6s ease-out;
        }
        @keyframes slideIn {
            from {
                transform: translateX(400px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
        @keyframes slideOut {
            from {
                transform: translateX(0);
                opacity: 1;
            }
            to {
                transform: translateX(400px);
                opacity: 0;
            }
        }
        #content {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
        }
        .section {
            display: none;
        }
        .section.active {
            display: block;
        }
        .npub {
            font-family: monospace;
            background: #f5f5f5;
            padding: 10px;
            border-radius: 4px;
            word-break: break-all;
            margin: 10px 0;
        }
        button {
            background: #0066cc;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px 5px 5px 0;
        }
        button:hover {
            background: #0052a3;
        }
        .error {
            color: red;
            padding: 10px;
            background: #ffe6e6;
            border-radius: 4px;
            margin: 10px 0;
        }
        .success {
            color: green;
            padding: 10px;
            background: #e6ffe6;
            border-radius: 4px;
            margin: 10px 0;
        }
        .group-item {
            padding: 12px;
            background: #f5f5f5;
            margin: 8px 0;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s;
            min-height: 80px;
        }
        .group-item:hover {
            background: #e6e6e6;
        }
        .group-item.active {
            background: #0066cc;
            color: white;
        }

        /* Mobile Responsive Styles */
        @media (max-width: 768px) {
            #menu-toggle {
                display: block;
            }

            #sidebar {
                position: fixed;
                left: -250px;
                top: 0;
                bottom: 0;
                width: 250px;
                z-index: 1000;
                transition: left 0.3s ease;
                box-shadow: 2px 0 5px rgba(0,0,0,0.3);
            }

            #sidebar.open {
                left: 0;
            }

            #content {
                padding: 10px;
            }

            /* Larger touch targets */
            button {
                min-height: 44px;
                font-size: 1em;
            }

            .nav-item {
                padding: 18px 20px;
                font-size: 1.1em;
            }

            .group-item {
                padding: 15px;
                font-size: 1em;
            }

            /* Chat area */
            #chat-messages {
                height: 50vh !important;
            }

            #chat-input {
                font-size: 16px !important; /* Prevents zoom on iOS */
            }

            /* Header adjustments */
            #header {
                padding: 12px 15px;
                font-size: 1.1em;
            }

            /* Modal adjustments */
            #create-group-modal > div,
            #invite-member-modal > div,
            #receive-modal > div,
            #qr-modal > div {
                margin: 20px;
                max-width: none !important;
                border-radius: 8px;
            }

            /* Reduce font sizes slightly */
            h2 {
                font-size: 1.3em;
            }

            /* Chat header buttons */
            #chat-section > div:first-child {
                flex-direction: column;
                align-items: stretch !important;
                gap: 10px;
            }

            #chat-section > div:first-child > div {
                flex-direction: column;
                width: 100%;
            }

            #chat-section > div:first-child button {
                width: 100%;
            }

            /* Input fields larger for touch */
            input[type="text"],
            textarea {
                font-size: 16px !important;
                padding: 12px !important;
            }
        }

        /* Overlay for sidebar on mobile */
        #sidebar-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            z-index: 999;
        }

        #sidebar-overlay.active {
            display: block;
        }
    </style>
</head>
<body>
    <div id="header">
        <button id="menu-toggle" onclick="toggleSidebar()">‚ò∞</button>
        <span>üîê MDK Ecash Web Client</span>
        <span></span> <!-- Spacer for flex layout -->
    </div>
    <div id="sidebar-overlay" onclick="closeSidebar()"></div>

    <div id="main">
        <!-- Sidebar -->
        <div id="sidebar">
            <div class="nav-item active" onclick="showSection('identity', event)">üîê Identity & Key Packages</div>
            <div class="nav-item" onclick="showSection('relays', event)">‚öôÔ∏è Relays</div>
            <div class="nav-item" onclick="showSection('wallet', event)">
                üí∞ Wallet
                <div id="sidebar-balance" class="wallet-balance">...</div>
            </div>
            <div class="nav-item" onclick="showSection('keypackages', event)">üîë Key Packages</div>
            <div class="nav-item" onclick="showSection('groups', event)">üì± Groups</div>
        </div>

        <!-- Content Area -->
        <div id="content">
            <!-- Identity Section -->
            <div id="identity-section" class="section active">
                <h2>Identity & Key Packages</h2>
                <div id="status">Loading WASM module...</div>
                <div id="npub-container" style="display: none;">
                    <p><strong>Your npub:</strong></p>
                    <div class="npub" id="npub"></div>
                </div>
                <div id="buttons" style="display: none;">
                    <button onclick="newKeys()">Generate New Keys</button>
                    <button onclick="clearKeys()">Clear Keys</button>
                </div>

                <!-- Key Packages Section -->
                <div id="keypackages-container" style="display: none; margin-top: 30px; padding-top: 20px; border-top: 1px solid #ddd;">
                    <h3>Key Packages</h3>
                    <p style="font-size: 0.9em; color: #666; margin-bottom: 15px;">
                        Key Packages allow others to invite you to groups. When someone adds you to a group, they fetch your most recent Key Package from relays.
                    </p>

                    <div id="keypackage-nudge" style="display: none; background: #fff3cd; border: 1px solid #ffc107; border-radius: 4px; padding: 15px; margin-bottom: 15px;">
                        <strong>‚ö†Ô∏è No KeyPackages available</strong>
                        <p style="margin: 8px 0 0 0; font-size: 0.9em;">Create a KeyPackage to allow others to invite you to groups.</p>
                    </div>

                    <div id="keypackage-list"></div>

                    <div style="display: flex; gap: 10px; margin-top: 15px;">
                        <button onclick="createKeyPackage()">+ Create KeyPackage</button>
                        <button onclick="checkForInvites()" style="background: #28a745;">üì¨ Check for Invites</button>
                    </div>
                </div>
            </div>

            <!-- Wallet Section -->
            <div id="wallet-section" class="section">
                <h2>üí∞ Wallet</h2>

                <!-- Main action buttons -->
                <div style="display: flex; gap: 15px; margin: 20px 0;">
                    <button onclick="showReceiveModal()" style="flex: 1; padding: 15px 30px; font-size: 1.1em; background: #28a745; border-radius: 8px;">
                        üì• Receive e-cash
                    </button>
                    <button onclick="showSendModal()" style="flex: 1; padding: 15px 30px; font-size: 1.1em; background: #0066cc; border-radius: 8px;">
                        üì§ Send e-cash
                    </button>
                </div>

                <div id="wallet-status" style="margin-bottom: 20px;">Initializing wallet...</div>

                <!-- Per-mint balances -->
                <div id="mint-balances" style="margin: 20px 0;">
                    <h3 style="margin-bottom: 10px;">Balances by Mint</h3>
                    <div id="mint-balances-list"></div>
                </div>

                <!-- Mint management -->
                <div style="margin-top: 30px; padding-top: 20px; border-top: 1px solid #ddd;">
                    <h3>Manage Trusted Mints</h3>
                    <div id="trusted-mints-list" style="margin: 15px 0;"></div>
                    <button onclick="showAddMintModal()">‚ûï Add Trusted Mint</button>
                </div>
            </div>

            <!-- Key Packages Section -->
            <div id="keypackages-section" class="section">
                <h2>üîë Join a Group</h2>
                <p>Click the button below to create a KeyPackage and wait for someone to invite you to a group.</p>
                <button onclick="createKeyPackageAndWait()">üöÄ Create KeyPackage & Wait for Invite</button>
                <div id="keypackages-status" style="margin-top: 20px;"></div>
            </div>

            <!-- Groups Section -->
            <div id="groups-section" class="section">
                <h2>üì± Groups</h2>

                <div id="groups-keypackage-nudge" style="display: none; background: #fff3cd; border: 1px solid #ffc107; border-radius: 4px; padding: 15px; margin-bottom: 15px;">
                    <strong>‚ö†Ô∏è Create a KeyPackage to receive group invites</strong>
                    <button onclick="showSection('identity'); createKeyPackage();" style="margin-left: 10px; padding: 5px 15px; background: #0066cc; color: white; border: none; border-radius: 4px; cursor: pointer;">Create One</button>
                </div>

                <div id="groups-status">Loading groups...</div>
                <div id="groups-list"></div>
                <button onclick="showCreateGroupModal()">‚ûï Create New Group</button>
            </div>

            <!-- Chat Section -->
            <div id="chat-section" class="section" style="display: none;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                    <h2 id="chat-group-name">üí¨ Chat</h2>
                    <div style="display: flex; gap: 10px;">
                        <button id="invite-member-btn" onclick="showInviteModal()">‚ûï Invite Member</button>
                        <button onclick="closeChat()">‚Üê Back to Groups</button>
                    </div>
                </div>
                <div id="chat-messages" style="height: 400px; overflow-y: auto; border: 1px solid #ccc; padding: 10px; margin-bottom: 10px; background: #f9f9f9;">
                    <p style="color: #666;">Loading messages...</p>
                </div>
                <div style="display: flex; gap: 10px; align-items: center;">
                    <button onclick="showSendEcashInChatModal()" style="padding: 10px 15px; font-size: 1.2em; background: #ff8800; border: none; border-radius: 4px; cursor: pointer;" title="Send e-cash to group">‚Çø</button>
                    <input type="text" id="chat-input" placeholder="Type a message..." style="flex: 1; padding: 10px; border: 1px solid #ccc; border-radius: 4px;">
                    <button id="send-button" onclick="sendChatMessage()" style="padding: 10px 20px;">Send</button>
                </div>
            </div>

            <!-- Relays Section -->
            <div id="relays-section" class="section">
                <h2>‚öôÔ∏è Relays</h2>
                <p>Configure which Nostr relays to use for group messaging.</p>

                <h3 style="margin-top: 20px;">Current Relays</h3>
                <div id="relays-list" style="margin: 10px 0;">
                    <p style="color: #666;">Loading relays...</p>
                </div>

                <h3 style="margin-top: 20px;">Add New Relay</h3>
                <div style="display: flex; gap: 10px; margin-top: 10px;">
                    <input type="text" id="relay-input" value="wss://" placeholder="wss://relay.example.com" style="flex: 1; padding: 10px; border: 1px solid #ccc; border-radius: 4px;">
                    <button onclick="addRelay()">‚ûï Add Relay</button>
                </div>
                <div id="relay-add-status" style="margin-top: 10px;"></div>
            </div>
        </div>
    </div>

    <!-- Receive Modal -->
    <div id="receive-modal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); z-index: 1000;">
        <div style="background: white; max-width: 600px; margin: 50px auto; padding: 20px; border-radius: 8px;">
            <h2>Receive e-cash Token</h2>
            <p>Paste your Cashu token below:</p>
            <textarea id="token-input" rows="6" style="width: 100%; font-family: monospace; padding: 10px; border: 1px solid #ddd; border-radius: 4px;"></textarea>
            <div style="margin-top: 10px;">
                <button onclick="receiveToken()">Receive</button>
                <button onclick="hideReceiveModal()">Cancel</button>
            </div>
            <div id="receive-status" style="margin-top: 10px;"></div>
        </div>
    </div>

    <!-- Send Modal -->
    <div id="send-modal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); z-index: 1000;">
        <div style="background: white; max-width: 600px; margin: 50px auto; padding: 20px; border-radius: 8px;">
            <h2>üì§ Send e-cash</h2>
            <div style="margin: 20px 0;">
                <label style="display: block; margin-bottom: 5px; font-weight: bold;">Mint:</label>
                <select id="send-mint-select" style="width: 100%; padding: 10px; border: 1px solid #ccc; border-radius: 4px; font-size: 1em; font-family: monospace;">
                    <option value="">Loading mints...</option>
                </select>
            </div>
            <div style="margin: 20px 0;">
                <label style="display: block; margin-bottom: 5px; font-weight: bold;">Amount (sats):</label>
                <input type="number" id="send-amount-input" placeholder="" min="1" style="width: 100%; padding: 10px; border: 1px solid #ccc; border-radius: 4px; font-size: 1.1em;">
            </div>
            <div id="send-status" style="margin-top: 10px;"></div>
            <div style="margin-top: 20px; display: flex; gap: 10px;">
                <button onclick="createSendToken()" style="flex: 1; padding: 12px; background: #0066cc; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 1em;">Create Token</button>
                <button onclick="hideSendModal()" style="padding: 12px 30px; background: #ccc; border: none; border-radius: 4px; cursor: pointer;">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Wait for Invite Modal -->
    <div id="wait-invite-modal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); z-index: 1000; overflow-y: auto;">
        <div style="background: white; max-width: 700px; margin: 50px auto; padding: 30px; border-radius: 8px; text-align: center;">
            <h2>‚è≥ Waiting for Group Invite</h2>
            <p style="margin: 20px 0;">Your KeyPackage is being published!</p>
            <div class="npub" id="wait-npub" style="margin: 20px 0;"></div>
            <div id="wait-status" style="margin: 20px 0; font-weight: bold; color: #0066cc;"></div>

            <!-- Relay Status -->
            <div id="wait-relay-status" style="margin: 20px auto; max-width: 500px; text-align: left; font-size: 0.9em; max-height: 200px; overflow-y: auto; background: #f9f9f9; padding: 10px; border-radius: 4px; display: none;">
                <div style="font-weight: bold; margin-bottom: 5px; text-align: center;">Relay Status:</div>
                <div id="wait-relay-list"></div>
            </div>

            <p style="color: #666; margin: 20px 0;" id="wait-instruction">Waiting for someone to invite you to a group...</p>
            <div style="margin-top: 20px;">
                <div style="display: inline-block; width: 40px; height: 40px; border: 4px solid #f3f3f3; border-top: 4px solid #0066cc; border-radius: 50%; animation: spin 1s linear infinite;"></div>
            </div>
        </div>
    </div>

    <!-- Create Group Modal -->
    <div id="create-group-modal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); z-index: 1000;">
        <div style="background: white; max-width: 500px; margin: 100px auto; padding: 30px; border-radius: 8px;">
            <h2>‚ûï Create New Group</h2>
            <div style="margin: 20px 0;">
                <label style="display: block; margin-bottom: 5px; font-weight: bold;">Group Name:</label>
                <input type="text" id="create-group-name" placeholder="My Group" style="width: 100%; padding: 10px; border: 1px solid #ccc; border-radius: 4px;">
            </div>
            <div style="margin: 20px 0;">
                <label style="display: block; margin-bottom: 5px; font-weight: bold;">Description (optional):</label>
                <textarea id="create-group-description" placeholder="What's this group about?" style="width: 100%; padding: 10px; border: 1px solid #ccc; border-radius: 4px; min-height: 60px;"></textarea>
            </div>
            <div style="margin: 20px 0;">
                <label style="display: block; margin-bottom: 5px; font-weight: bold;">First member to invite:</label>
                <input type="text" id="create-group-first-member" placeholder="npub1..." style="width: 100%; padding: 10px; border: 1px solid #ccc; border-radius: 4px; font-family: monospace; font-size: 0.9em;">
                <p style="font-size: 0.9em; color: #666; margin-top: 5px;">Groups require you and at least 1 other member. You can invite more people later.</p>
            </div>
            <div id="create-group-status" style="margin: 20px 0; color: #0066cc;"></div>
            <div style="display: flex; gap: 10px; margin-top: 20px;">
                <button onclick="createGroup()" style="flex: 1; padding: 12px; background: #0066cc; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 1em;">Create Group</button>
                <button onclick="closeCreateGroupModal()" style="padding: 12px 30px; background: #ccc; border: none; border-radius: 4px; cursor: pointer;">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Invite Member Modal -->
    <div id="invite-member-modal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); z-index: 1000;">
        <div style="background: white; max-width: 500px; margin: 100px auto; padding: 30px; border-radius: 8px;">
            <h2>‚ûï Invite Member to Group</h2>
            <div style="margin: 20px 0;">
                <label style="display: block; margin-bottom: 5px; font-weight: bold;">Member's npub:</label>
                <input type="text" id="invite-member-npub" placeholder="npub1abc..." style="width: 100%; padding: 10px; border: 1px solid #ccc; border-radius: 4px; font-family: monospace; font-size: 0.9em;">
                <p style="font-size: 0.9em; color: #666; margin-top: 5px;">Enter the npub of the person you want to invite</p>
            </div>
            <div id="invite-member-status" style="margin: 20px 0; color: #0066cc;"></div>
            <div style="display: flex; gap: 10px; margin-top: 20px;">
                <button onclick="inviteMember()" style="flex: 1; padding: 12px; background: #0066cc; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 1em;">Send Invite</button>
                <button onclick="closeInviteModal()" style="padding: 12px 30px; background: #ccc; border: none; border-radius: 4px; cursor: pointer;">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Add Mint Modal -->
    <div id="add-mint-modal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); z-index: 1000;">
        <div style="background: white; max-width: 500px; margin: 100px auto; padding: 30px; border-radius: 8px;">
            <h2>‚ûï Add Trusted Mint</h2>
            <div style="margin: 20px 0;">
                <label style="display: block; margin-bottom: 5px; font-weight: bold;">Mint URL:</label>
                <input type="text" id="add-mint-url" placeholder="https://mint.example.com" style="width: 100%; padding: 10px; border: 1px solid #ccc; border-radius: 4px; font-family: monospace; font-size: 0.9em;">
                <p style="font-size: 0.9em; color: #666; margin-top: 5px;">Only add mints you trust. Tokens can only be redeemed from trusted mints.</p>
            </div>
            <div id="add-mint-status" style="margin: 20px 0;"></div>
            <div style="display: flex; gap: 10px; margin-top: 20px;">
                <button onclick="addTrustedMint()" style="flex: 1; padding: 12px; background: #0066cc; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 1em;">Add Mint</button>
                <button onclick="closeAddMintModal()" style="padding: 12px 30px; background: #ccc; border: none; border-radius: 4px; cursor: pointer;">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Untrusted Mint Warning Modal -->
    <div id="untrusted-mint-modal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); z-index: 1000;">
        <div style="background: white; max-width: 600px; margin: 100px auto; padding: 30px; border-radius: 8px;">
            <h2 style="color: #ff6600;">‚ö†Ô∏è Untrusted Mint Warning</h2>
            <div style="margin: 20px 0; background: #fff3e0; border-left: 4px solid #ff6600; padding: 15px;">
                <p style="font-weight: bold; margin-bottom: 10px;">This token is from an untrusted mint:</p>
                <code id="untrusted-mint-url" style="display: block; background: #f5f5f5; padding: 10px; word-break: break-all; margin: 10px 0;"></code>
                <p style="margin-top: 10px;">Redeeming tokens from untrusted mints carries risk. Only proceed if you trust this mint.</p>
            </div>
            <div style="margin: 20px 0;">
                <p><strong>Token amount:</strong> <span id="untrusted-token-amount"></span> sats</p>
            </div>
            <div style="display: flex; gap: 10px; margin-top: 20px;">
                <button onclick="addMintAndRedeem()" style="flex: 1; padding: 12px; background: #ff6600; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 1em;">Add to Trusted & Redeem</button>
                <button onclick="closeUntrustedMintModal()" style="padding: 12px 30px; background: #ccc; border: none; border-radius: 4px; cursor: pointer;">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Redemption Progress Modal -->
    <div id="redemption-progress-modal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); z-index: 1001;">
        <div style="background: white; max-width: 500px; margin: 100px auto; padding: 30px; border-radius: 8px; text-align: center;">
            <h2 id="redemption-title">üí∞ Redeeming Token</h2>
            <div id="redemption-status" style="margin: 30px 0; font-size: 1.1em;"></div>
            <div id="redemption-close-btn" style="display: none;">
                <button onclick="hideRedemptionProgress()" style="padding: 10px 30px; font-size: 1em;">Close</button>
            </div>
        </div>
    </div>

    <!-- Send E-cash in Chat Modal -->
    <div id="send-ecash-chat-modal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); z-index: 1000;">
        <div style="background: white; max-width: 600px; margin: 50px auto; padding: 20px; border-radius: 8px;">
            <h2>‚Çø Send e-cash to Group</h2>
            <div style="margin: 20px 0;">
                <label style="display: block; margin-bottom: 5px; font-weight: bold;">Mint:</label>
                <select id="send-ecash-chat-mint-select" style="width: 100%; padding: 10px; border: 1px solid #ccc; border-radius: 4px; font-size: 1em; font-family: monospace;">
                    <option value="">Loading mints...</option>
                </select>
            </div>
            <div style="margin: 20px 0;">
                <label style="display: block; margin-bottom: 5px; font-weight: bold;">Amount (sats):</label>
                <input type="number" id="send-ecash-chat-amount" placeholder="" min="1" style="width: 100%; padding: 10px; border: 1px solid #ccc; border-radius: 4px; font-size: 1.1em;">
            </div>
            <div id="send-ecash-chat-status" style="margin-top: 10px;"></div>
            <div style="margin-top: 20px; display: flex; gap: 10px;">
                <button onclick="sendEcashToChat()" style="flex: 1; padding: 12px; background: #ff8800; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 1em;">Send to Group</button>
                <button onclick="hideSendEcashInChatModal()" style="padding: 12px 30px; background: #ccc; border: none; border-radius: 4px; cursor: pointer;">Cancel</button>
            </div>
        </div>
    </div>

    <style>
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>

    <script type="module">
        // ==========================================
        // TAB LOCK MECHANISM
        // ==========================================
        const LOCK_KEY = 'mdk_tab_lock';
        const LOCK_HEARTBEAT_INTERVAL = 2000; // 2 seconds
        const LOCK_STALE_TIMEOUT = 5000; // 5 seconds

        let hasLock = false;
        let heartbeatInterval = null;
        let lockCheckInterval = null;

        function acquireLock() {
            const now = Date.now();
            const lockData = localStorage.getItem(LOCK_KEY);

            if (lockData) {
                try {
                    const lock = JSON.parse(lockData);
                    const age = now - lock.timestamp;

                    // If lock is fresh (< 5 sec), another tab owns it
                    if (age < LOCK_STALE_TIMEOUT) {
                        return false;
                    }
                    // Lock is stale, we can take it
                    console.log('Lock was stale, taking over');
                } catch (e) {
                    console.error('Failed to parse lock data:', e);
                }
            }

            // Acquire the lock
            const lockInfo = {
                timestamp: now,
                tabId: Math.random().toString(36).substring(7)
            };
            localStorage.setItem(LOCK_KEY, JSON.stringify(lockInfo));
            hasLock = true;
            console.log('üîí Lock acquired');
            return true;
        }

        function updateHeartbeat() {
            if (!hasLock) return;

            const now = Date.now();
            const lockInfo = {
                timestamp: now,
                tabId: 'current'
            };
            localStorage.setItem(LOCK_KEY, JSON.stringify(lockInfo));
        }

        function releaseLock() {
            if (hasLock) {
                localStorage.removeItem(LOCK_KEY);
                hasLock = false;
                console.log('üîì Lock released');
            }
        }

        function showLockWarning() {
            document.body.innerHTML = `
                <div style="display: flex; align-items: center; justify-content: center; height: 100vh; background: #f5f5f5; font-family: Arial, sans-serif;">
                    <div style="text-align: center; padding: 40px; max-width: 600px; background: white; border-radius: 12px; box-shadow: 0 2px 10px rgba(0,0,0,0.1);">
                        <div style="font-size: 4em; margin-bottom: 20px;">üëã</div>
                        <h2 style="color: #333; margin-bottom: 20px; font-weight: normal;">Already open in another tab</h2>
                        <p style="font-size: 1.1em; color: #666; margin-bottom: 20px; line-height: 1.6;">
                            You've already got this app running somewhere else. To keep your wallet and messages safe,
                            please use that tab instead.
                        </p>
                        <p style="font-size: 0.95em; color: #888; margin-top: 30px; line-height: 1.6;">
                            If you closed the other tab, just wait a moment and <a href="#" onclick="location.reload()" style="color: #0066cc; text-decoration: none; border-bottom: 1px solid #0066cc;">click here to reload</a>.
                        </p>
                    </div>
                </div>
            `;
        }

        // Try to acquire lock on load
        if (!acquireLock()) {
            showLockWarning();
            throw new Error('Cannot start - app already open in another tab');
        }

        // Send heartbeats
        heartbeatInterval = setInterval(updateHeartbeat, LOCK_HEARTBEAT_INTERVAL);

        // Release lock on unload
        window.addEventListener('beforeunload', () => {
            releaseLock();
        });

        // Listen for storage events (another tab released lock)
        window.addEventListener('storage', (e) => {
            if (e.key === LOCK_KEY) {
                if (!hasLock) {
                    // We don't have lock, check if we can acquire it now
                    if (e.newValue === null || e.newValue === '') {
                        // Lock was released, try to acquire
                        setTimeout(() => {
                            if (acquireLock()) {
                                location.reload();
                            }
                        }, 100);
                    }
                }
            }
        });

        // Periodically check if we still have the lock
        lockCheckInterval = setInterval(() => {
            if (hasLock) {
                const lockData = localStorage.getItem(LOCK_KEY);
                if (!lockData) {
                    console.error('Lock was lost!');
                    hasLock = false;
                    showLockWarning();
                    clearInterval(heartbeatInterval);
                    clearInterval(lockCheckInterval);
                }
            }
        }, 1000);

        // ==========================================
        // END TAB LOCK MECHANISM
        // ==========================================

        import init, {
            get_or_create_keys,
            generate_keys,
            get_npub,
            get_pubkey_hex,
            clear_keys,
            init_wallet,
            get_balance,
            receive_token,
            send_ecash,
            parse_token_info,
            get_groups,
            fetch_welcome_events,
            process_pending_welcomes,
            create_keypackage_and_wait_for_invite,
            create_and_publish_keypackage,
            subscribe_to_welcome_messages,
            debug_fetch_welcome_events,
            process_welcome_event,
            create_group_with_members,
            invite_member_to_group,
            send_message_to_group,
            get_messages_for_group,
            subscribe_to_group_messages,
            get_relays,
            add_relay,
            remove_relay,
            log,
            // Mint management functions
            get_trusted_mints,
            add_trusted_mint,
            remove_trusted_mint,
            is_mint_trusted,
            set_current_mint,
            get_current_mint,
            get_all_mint_balances
        } from './pkg/mdk_ecash_web.js';

        let wasm;

        // Unread message tracking
        function getLastReadAt(groupId) {
            const key = `last_read_at_${groupId}`;
            const value = localStorage.getItem(key);
            return value ? parseInt(value) : 0;
        }

        function setLastReadAt(groupId, timestamp) {
            const key = `last_read_at_${groupId}`;
            localStorage.setItem(key, timestamp.toString());
        }

        // KeyPackage management in localStorage
        function getCreatedKeyPackages() {
            const data = localStorage.getItem('created_keypackages');
            return data ? JSON.parse(data) : [];
        }

        function saveCreatedKeyPackage(eventId, createdAt) {
            const packages = getCreatedKeyPackages();
            packages.push({ event_id: eventId, created_at: createdAt });
            localStorage.setItem('created_keypackages', JSON.stringify(packages));
        }

        function getConsumedKeyPackages() {
            const data = localStorage.getItem('consumed_keypackages');
            return data ? JSON.parse(data) : {};
        }

        function markKeyPackageConsumed(kpEventId, groupId) {
            const consumed = getConsumedKeyPackages();
            consumed[kpEventId] = groupId;
            localStorage.setItem('consumed_keypackages', JSON.stringify(consumed));
        }

        function countUnreadMessages(groupId, messages, lastReadAt) {
            return messages.filter(msg => msg.created_at > lastReadAt).length;
        }

        // Mobile sidebar toggle
        window.toggleSidebar = function() {
            const sidebar = document.getElementById('sidebar');
            const overlay = document.getElementById('sidebar-overlay');
            sidebar.classList.toggle('open');
            overlay.classList.toggle('active');
        };

        window.closeSidebar = function() {
            const sidebar = document.getElementById('sidebar');
            const overlay = document.getElementById('sidebar-overlay');
            sidebar.classList.remove('open');
            overlay.classList.remove('active');
        };

        // Swipe to close sidebar on mobile
        let touchStartX = 0;
        let touchStartY = 0;
        let touchEndX = 0;
        let touchEndY = 0;

        window.addEventListener('DOMContentLoaded', () => {
            const sidebar = document.getElementById('sidebar');

            sidebar.addEventListener('touchstart', (e) => {
                touchStartX = e.changedTouches[0].screenX;
                touchStartY = e.changedTouches[0].screenY;
            });

            sidebar.addEventListener('touchend', (e) => {
                touchEndX = e.changedTouches[0].screenX;
                touchEndY = e.changedTouches[0].screenY;
                handleSwipe();
            });

            function handleSwipe() {
                const diffX = touchStartX - touchEndX;
                const diffY = touchStartY - touchEndY;

                // Only detect horizontal swipes (more horizontal than vertical)
                if (Math.abs(diffX) > Math.abs(diffY)) {
                    // Swipe left (to close) - need at least 50px movement
                    // diffX > 0 means swiped left (start was right of end)
                    if (diffX > 50) {
                        closeSidebar();
                    }
                }
            }
        });

        // Navigation
        window.showSection = function(sectionName, event, skipHashUpdate = false) {
            // Close sidebar on mobile when navigating
            closeSidebar();
            // Hide all sections
            document.querySelectorAll('.section').forEach(s => s.classList.remove('active'));
            document.querySelectorAll('.nav-item').forEach(n => n.classList.remove('active'));

            // Also hide chat section (uses inline display style)
            document.getElementById('chat-section').style.display = 'none';

            // Show selected section
            document.getElementById(`${sectionName}-section`).classList.add('active');

            // Mark the nav item as active (if called from nav click)
            if (event && event.target) {
                event.target.classList.add('active');
            } else {
                // Called programmatically, find and activate the nav item
                const navItem = Array.from(document.querySelectorAll('.nav-item'))
                    .find(item => item.getAttribute('onclick')?.includes(`'${sectionName}'`));
                if (navItem) {
                    navItem.classList.add('active');
                }
            }

            // Load content if needed
            if (sectionName === 'groups') {
                refreshGroups();
            } else if (sectionName === 'relays') {
                loadRelays();
            }

            // Update URL hash (unless we're restoring from hash)
            if (!skipHashUpdate) {
                window.location.hash = sectionName;
            }
        };

        async function loadWasm() {
            try {
                wasm = await init();
                log("WASM module loaded successfully");
                await displayNpub();

                // Get current user's pubkey for message styling
                currentUserPubkey = await get_pubkey_hex();

                await initializeWallet();
                await initializeGroups();

                // Initialize KeyPackages
                document.getElementById('keypackages-container').style.display = 'block';
                await refreshKeyPackageList();
                // await initializeWelcomeSubscription();

                document.getElementById('buttons').style.display = 'block';
                document.getElementById('status').innerHTML = '<div class="success">‚úì Ready</div>';

                // Restore state from URL hash
                await restoreFromHash();
            } catch (err) {
                console.error('Failed to load WASM:', err);
                document.getElementById('status').innerHTML =
                    `<div class="error">Failed to load WASM: ${err}</div>`;
            }
        }

        // Restore state from URL hash
        async function restoreFromHash() {
            const hash = window.location.hash.slice(1); // Remove leading #
            if (!hash) return;

            if (hash.startsWith('chat:')) {
                // Format: chat:groupId:groupName
                const parts = hash.split(':');
                if (parts.length >= 3) {
                    const groupId = parts[1];
                    const groupName = decodeURIComponent(parts.slice(2).join(':'));

                    // Fetch groups to get admin status
                    try {
                        const groupsJson = await get_groups();
                        const groups = JSON.parse(groupsJson);
                        const group = groups.find(g => g.id === groupId);
                        const isAdmin = group ? group.is_admin : false;

                        await openChat(groupId, groupName, isAdmin, true); // isAdmin, skipHashUpdate=true
                    } catch (err) {
                        console.error('Failed to fetch admin status:', err);
                        await openChat(groupId, groupName, false, true); // Default to non-admin
                    }
                }
            } else {
                // Regular section like 'wallet', 'groups', etc.
                if (document.getElementById(`${hash}-section`)) {
                    showSection(hash, null, true); // skipHashUpdate=true
                }
            }
        }

        // Listen for hash changes (browser back/forward)
        window.addEventListener('hashchange', async () => {
            await restoreFromHash();
        });

        async function initializeWallet() {
            try {
                document.getElementById('wallet-status').textContent = 'Initializing wallet...';

                await init_wallet();
                document.getElementById('wallet-status').innerHTML = '<div class="success">‚úì Wallet ready</div>';

                // Load and display balances
                await refreshMintBalances();

                // Load and display trusted mints
                await refreshTrustedMints();

                log("Wallet initialized");
            } catch (err) {
                console.error('Failed to initialize wallet:', err);
                document.getElementById('wallet-status').innerHTML =
                    `<div class="error">Failed to initialize wallet: ${err}</div>`;
            }
        }

        // Track previous balance for animation
        let previousTotalBalance = null;

        // Update sidebar balance with animation
        function updateSidebarBalance(totalBalance) {
            const balanceEl = document.getElementById('sidebar-balance');
            if (!balanceEl) return;

            // Remove any existing animation classes
            balanceEl.classList.remove('balance-increase', 'balance-decrease');

            // Update text
            balanceEl.textContent = `${totalBalance} sats`;

            // Animate if balance changed
            if (previousTotalBalance !== null && previousTotalBalance !== totalBalance) {
                if (totalBalance > previousTotalBalance) {
                    balanceEl.classList.add('balance-increase');
                } else {
                    balanceEl.classList.add('balance-decrease');
                }
            }

            previousTotalBalance = totalBalance;
        }

        // Refresh per-mint balances display
        async function refreshMintBalances() {
            try {
                const balancesJson = await get_all_mint_balances();
                const balances = JSON.parse(balancesJson);
                const currentMint = await get_current_mint();

                const listDiv = document.getElementById('mint-balances-list');

                // Calculate total balance
                const totalBalance = balances.reduce((sum, b) => sum + b.balance, 0);
                updateSidebarBalance(totalBalance);

                if (balances.length === 0) {
                    listDiv.innerHTML = '<p style="color: #666; font-style: italic;">No balances yet</p>';
                    return;
                }

                listDiv.innerHTML = balances.map(b => {
                    const isCurrent = b.mint === currentMint;
                    const trustBadge = b.is_trusted
                        ? '<span style="color: green; margin-left: 10px;">‚úì Trusted</span>'
                        : '<span style="color: #ff6600; margin-left: 10px;">‚ö†Ô∏è Untrusted</span>';

                    return `
                        <div style="background: ${isCurrent ? '#e6f3ff' : '#f9f9f9'}; border: 1px solid ${isCurrent ? '#0066cc' : '#ddd'}; border-radius: 4px; padding: 15px; margin: 10px 0;">
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <div style="flex: 1; min-width: 0;">
                                    <code style="font-size: 0.9em; word-break: break-all;">${b.mint}</code>
                                    ${trustBadge}
                                </div>
                                <strong style="font-size: 1.2em; margin-left: 15px;">${b.balance} sats</strong>
                            </div>
                            <div style="margin-top: 10px;">
                                ${isCurrent
                                    ? '<span style="color: #0066cc; font-weight: bold; font-size: 0.9em;">‚óè Current</span>'
                                    : '<button onclick="setCurrentMint(\'' + b.mint + '\')" style="font-size: 0.9em; padding: 5px 15px;">Set as Current</button>'}
                            </div>
                        </div>
                    `;
                }).join('');
            } catch (err) {
                console.error('Failed to load mint balances:', err);
            }
        }

        // Refresh trusted mints list
        async function refreshTrustedMints() {
            try {
                const mintsJson = await get_trusted_mints();
                const mints = JSON.parse(mintsJson);

                const listDiv = document.getElementById('trusted-mints-list');

                if (mints.length === 0) {
                    listDiv.innerHTML = '<p style="color: #666; font-style: italic;">No trusted mints yet. Add one to get started!</p>';
                    return;
                }

                listDiv.innerHTML = mints.map(mint => {
                    return `
                        <div style="background: #f9f9f9; border: 1px solid #ddd; border-radius: 4px; padding: 10px; margin: 8px 0; display: flex; justify-content: space-between; align-items: center;">
                            <code style="flex: 1; font-size: 0.9em; word-break: break-all;">${mint}</code>
                            <button onclick="removeTrustedMint('${mint}')" style="background: #dc3545; padding: 5px 15px; font-size: 0.85em; margin-left: 10px;">Remove</button>
                        </div>
                    `;
                }).join('');
            } catch (err) {
                console.error('Failed to load trusted mints:', err);
            }
        }

        // Modal functions
        window.showAddMintModal = function() {
            document.getElementById('add-mint-modal').style.display = 'block';
            document.getElementById('add-mint-url').value = '';
            document.getElementById('add-mint-status').innerHTML = '';
        };

        window.closeAddMintModal = function() {
            document.getElementById('add-mint-modal').style.display = 'none';
        };

        window.addTrustedMint = async function() {
            const url = document.getElementById('add-mint-url').value.trim();
            if (!url) {
                document.getElementById('add-mint-status').innerHTML = '<div class="error">Please enter a mint URL</div>';
                return;
            }

            // Show validating status
            document.getElementById('add-mint-status').innerHTML = '<div style="color: #0066cc;">‚è≥ Validating mint...</div>';

            try {
                console.log('Calling add_trusted_mint for:', url);
                const added = await add_trusted_mint(url);
                console.log('add_trusted_mint returned:', added);

                if (added) {
                    document.getElementById('add-mint-status').innerHTML = '<div class="success">‚úì Mint added successfully!</div>';
                    await refreshTrustedMints();
                    await refreshMintBalances();
                    setTimeout(closeAddMintModal, 1500);
                } else {
                    document.getElementById('add-mint-status').innerHTML = '<div class="error">Mint already in trusted list</div>';
                }
            } catch (err) {
                console.error('Failed to add mint:', err);
                document.getElementById('add-mint-status').innerHTML = `<div class="error">Failed to add mint: ${err}</div>`;
            }
        };

        window.removeTrustedMint = async function(mintUrl) {
            if (!confirm(`Remove ${mintUrl} from trusted mints?`)) {
                return;
            }

            try {
                await remove_trusted_mint(mintUrl);
                await refreshTrustedMints();
                await refreshMintBalances();
            } catch (err) {
                console.error('Failed to remove mint:', err);
                alert(`Failed to remove mint: ${err}`);
            }
        };

        window.setCurrentMint = async function(mintUrl) {
            try {
                await set_current_mint(mintUrl);
                await refreshTrustedMints();
                await refreshMintBalances();
            } catch (err) {
                console.error('Failed to set current mint:', err);
                alert(`Failed to set current mint: ${err}`);
            }
        };

        // Untrusted mint warning modal
        let pendingTokenRedemption = null;

        window.closeUntrustedMintModal = function() {
            document.getElementById('untrusted-mint-modal').style.display = 'none';
            pendingTokenRedemption = null;
        };

        window.addMintAndRedeem = async function() {
            if (!pendingTokenRedemption) return;

            // Save the token info before closing modal (which nulls pendingTokenRedemption)
            const { mint, token } = pendingTokenRedemption;

            // Close untrusted mint warning modal and show progress modal
            closeUntrustedMintModal();
            showRedemptionProgress();
            document.getElementById('redemption-status').innerHTML = 'üîÑ Adding mint and redeeming...';

            try {

                // Add mint to trusted list
                await add_trusted_mint(mint);

                // Now redeem directly (mint is now trusted, so redeemTokenInternal will succeed)
                const amount = await receive_token(token);

                // Update balance display
                await refreshMintBalances();

                // Show success in progress modal
                document.getElementById('redemption-status').innerHTML = `<div class="success" style="font-size: 1.2em;">‚úÖ Successfully received ${amount} sats!</div>`;
                document.getElementById('redemption-close-btn').style.display = 'block';
            } catch (err) {
                console.error('Failed to add mint and redeem:', err);

                // Show error in progress modal
                document.getElementById('redemption-status').innerHTML = `<div class="error" style="font-size: 1.1em;">‚ùå Failed: ${err}</div>`;
                document.getElementById('redemption-close-btn').style.display = 'block';
            }
        };

        // Track which groups we've already subscribed to
        const subscribedGroups = new Set();

        async function subscribeToAllGroups() {
            try {
                const groupsJson = await get_groups();
                const groups = JSON.parse(groupsJson);

                for (const group of groups) {
                    // Skip if already subscribed
                    if (subscribedGroups.has(group.id)) {
                        continue;
                    }

                    console.log(`üì° Subscribing to group: ${group.name} (${group.id.substring(0, 16)}...)`);

                    // Subscribe and mark as subscribed
                    await subscribe_to_group_messages(group.id, async (message) => {
                        console.log(`üì® Message in ${group.name}:`, message);

                        // If this group's chat is currently open, add the message
                        if (currentChatGroupId === group.id) {
                            await addMessageToChat(message);
                        }

                        // Refresh groups list to update "Last activity" timestamp
                        // Pass false to skip re-subscribing (we're already subscribed)
                        await refreshGroups(false);
                    });

                    subscribedGroups.add(group.id);
                    console.log(`‚úÖ Subscribed to group: ${group.name}`);
                }
            } catch (err) {
                console.error('Failed to subscribe to groups:', err);
            }
        }

        async function initializeGroups() {
            // Disable chat input during initial load
            setChatInputEnabled(false);
            await refreshGroups(); // Now auto-subscribes
            // Note: chat input will be re-enabled when openChat() -> loadMessages() completes
        }

        window.refreshGroups = async function(autoSubscribe = true) {
            try {
                console.log('üîÑ Refreshing groups list...');
                document.getElementById('groups-status').textContent = 'Loading groups...';

                const groupsJson = await get_groups();
                console.log('  Received groups JSON:', groupsJson);
                const groups = JSON.parse(groupsJson);
                console.log(`  Parsed ${groups.length} group(s)`);

                const listDiv = document.getElementById('groups-list');
                if (groups.length === 0) {
                    listDiv.innerHTML = '<p style="color: #666;">No groups yet. Accept an invite to get started!</p>';
                    document.getElementById('groups-status').innerHTML = '<div class="success">‚úì Ready (0 groups)</div>';
                } else {
                    // Sort by most recent activity (last_message_at), most recent first
                    groups.sort((a, b) => {
                        const aTime = a.last_message_at || 0;
                        const bTime = b.last_message_at || 0;
                        return bTime - aTime; // Descending order (newest first)
                    });

                    // Fetch last message for each group to show preview and count unread
                    const groupsWithPreviews = await Promise.all(groups.map(async (group) => {
                        let messagePreview = '';
                        let unreadCount = 0;

                        // Check if group has any messages (using last_message_at instead of last_message_id)
                        console.log(`Fetching preview for group ${group.name}, has last_message_at: ${!!group.last_message_at}`);
                        if (group.last_message_at) {
                            try {
                                const messagesJson = await get_messages_for_group(group.id);
                                const messages = JSON.parse(messagesJson);
                                console.log(`  Group ${group.name} has ${messages.length} messages`);

                                // Count unread messages
                                const lastReadAt = getLastReadAt(group.id);
                                unreadCount = countUnreadMessages(group.id, messages, lastReadAt);
                                console.log(`  Group ${group.name} has ${unreadCount} unread messages (last read: ${lastReadAt})`);

                                if (messages.length > 0) {
                                    // Get the last message (most recent)
                                    const lastMsg = messages[messages.length - 1];
                                    const content = lastMsg.content || '';
                                    console.log(`  Last message content: "${content}"`);
                                    // Truncate to 50 chars and strip any special commands
                                    const truncated = content.length > 50 ? content.substring(0, 50) + '...' : content;
                                    messagePreview = truncated;
                                    console.log(`  Preview set to: "${messagePreview}"`);
                                }
                            } catch (err) {
                                console.error('Failed to fetch message preview:', err);
                            }
                        }
                        return { ...group, messagePreview, unreadCount };
                    }));

                    listDiv.innerHTML = groupsWithPreviews.map(group => {
                        console.log(`  Rendering group: ${group.name || 'Unnamed'} (ID: ${group.id})`);
                        const memberCount = group.member_count || 0;
                        const adminBadge = group.is_admin ? '<span style="color: #ffa500; font-size: 0.8em; margin-left: 5px;">üëë Admin</span>' : '';
                        const preview = group.messagePreview
                            ? `<div style="color: #888; font-size: 0.9em; margin-top: 4px; font-style: italic;">${group.messagePreview}</div>`
                            : '';

                        // Unread badge and timestamp
                        const hasUnread = group.unreadCount > 0;
                        const unreadBadge = hasUnread
                            ? `<span style="background: #0066cc; color: white; border-radius: 12px; padding: 3px 10px; font-size: 0.85em; font-weight: bold; margin-right: 8px; display: inline-block;">${group.unreadCount}</span>`
                            : '';

                        // Extra bold group name if unread (900 weight)
                        const groupNameStyle = hasUnread ? 'font-weight: 900;' : '';

                        // Format timestamp with badge to the left of date/time
                        let timestampHtml = '';
                        if (group.last_message_at) {
                            const date = new Date(group.last_message_at * 1000);
                            const dateStr = date.toLocaleDateString('en-CA'); // YYYY-MM-DD format
                            const timeStr = date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                            timestampHtml = `
                                <div style="display: flex; align-items: center; gap: 8px;">
                                    ${unreadBadge}
                                    <div style="text-align: right; color: #999; font-size: 0.85em; line-height: 1.3;">
                                        <div>${dateStr}</div>
                                        <div>${timeStr}</div>
                                    </div>
                                </div>`;
                        } else if (hasUnread) {
                            // If no timestamp but has unread, just show badge
                            timestampHtml = `<div>${unreadBadge}</div>`;
                        }

                        console.log(`  Rendering group ${group.name}: messagePreview="${group.messagePreview}", unreadCount=${group.unreadCount}`);
                        return `
                        <div class="group-item" onclick="openChat('${group.id}', '${(group.name || 'Unnamed Group').replace(/'/g, "\\'")}', ${group.is_admin})" style="cursor: pointer; padding: 15px; border-bottom: 1px solid #eee; transition: background 0.2s; display: flex; justify-content: space-between; align-items: flex-start;" onmouseover="this.style.background='#f5f5f5'" onmouseout="this.style.background='white'">
                            <div style="flex: 1; min-width: 0;">
                                <strong style="font-size: 1.1em; ${groupNameStyle}">${group.name || 'Unnamed Group'}</strong>${adminBadge}
                                <span style="color: #666; font-size: 0.9em; margin-left: 10px;">üë• ${memberCount} member${memberCount !== 1 ? 's' : ''}</span>
                                <br>
                                <small style="color: #666;">${group.description || 'No description'}</small>${preview}
                            </div>
                            ${timestampHtml}
                        </div>`;
                    }).join('');
                    document.getElementById('groups-status').innerHTML =
                        `<div class="success">‚úì Found ${groups.length} group(s)</div>`;
                }

                console.log(`‚úÖ Groups list refreshed (${groups.length} group(s))`);
                log(`Loaded ${groups.length} group(s)`);

                // Auto-subscribe to any new groups
                if (autoSubscribe) {
                    await subscribeToAllGroups();
                }
            } catch (err) {
                console.error('‚ùå Failed to fetch groups:', err);
                document.getElementById('groups-status').innerHTML =
                    `<div class="error">Failed to load: ${err}</div>`;
            }
        };

        window.processWelcomes = async function() {
            const statusDiv = document.getElementById('groups-status');
            statusDiv.innerHTML = 'Checking for new group invites...';

            try {
                // Step 1: Fetch Welcome events from Nostr relays
                statusDiv.innerHTML = 'Fetching invites from Nostr relays...';
                const fetched = await fetch_welcome_events();
                log(`Fetched and processed ${fetched} Welcome event(s)`);

                // Step 2: Auto-accept any pending welcomes
                statusDiv.innerHTML = 'Processing invites...';
                const count = await process_pending_welcomes();

                if (count > 0) {
                    statusDiv.innerHTML = `<div class="success">‚úÖ Joined ${count} new group(s)!</div>`;
                    // Refresh groups list and auto-subscribe to new groups
                    await refreshGroups();
                } else {
                    statusDiv.innerHTML = '<div class="success">No new invites found</div>';
                }
            } catch (err) {
                console.error('Failed to process welcomes:', err);
                statusDiv.innerHTML = `<div class="error">Failed to process invites: ${err}</div>`;
            }
        };

        // Chat interface variables
        let currentChatGroupId = null;
        let currentChatGroupName = null;
        let currentUserIsAdmin = false;

        window.openChat = async function(groupId, groupName, isAdmin = false, skipHashUpdate = false) {
            console.log(`üí¨ Opening chat for group: ${groupName} (${groupId}), isAdmin: ${isAdmin}`);

            // Close sidebar on mobile
            closeSidebar();

            // Mark as read (current timestamp)
            setLastReadAt(groupId, Math.floor(Date.now() / 1000));

            // Store current group info
            currentChatGroupId = groupId;
            currentChatGroupName = groupName;
            currentUserIsAdmin = isAdmin;

            // Update invite button state based on admin status
            const inviteBtn = document.getElementById('invite-member-btn');
            if (isAdmin) {
                inviteBtn.disabled = false;
                inviteBtn.style.opacity = '1';
                inviteBtn.style.cursor = 'pointer';
                inviteBtn.title = '';
            } else {
                inviteBtn.disabled = true;
                inviteBtn.style.opacity = '0.5';
                inviteBtn.style.cursor = 'not-allowed';
                inviteBtn.title = 'Only admins can invite members';
            }

            // Hide all sections
            document.querySelectorAll('.section').forEach(s => s.classList.remove('active'));

            // Update UI and show chat
            document.getElementById('chat-group-name').textContent = `üí¨ ${groupName}`;
            document.getElementById('chat-section').style.display = 'block';

            // Update URL hash (encode groupName to handle special characters) unless we're restoring from hash
            if (!skipHashUpdate) {
                window.location.hash = `chat:${groupId}:${encodeURIComponent(groupName)}`;
            }

            // Load messages
            await loadMessages(groupId);

            // Note: Subscription already active from startup (subscribeToAllGroups)
        };

        window.closeChat = function() {
            console.log('‚Üê Closing chat');
            currentChatGroupId = null;
            currentChatGroupName = null;
            showSection('groups');
        };

        // Store tokens by ID for redemption
        const tokenStore = new Map();
        let tokenIdCounter = 0;

        // Store current user's pubkey for message styling
        let currentUserPubkey = null;

        // Format message content, detecting and formatting Cashu tokens
        async function formatMessageContent(content) {
            // Detect cashu tokens (start with cashuA or cashuB)
            const tokenRegex = /cashu[AB][A-Za-z0-9_=\-]+/g;
            const tokens = content.match(tokenRegex);

            if (!tokens) {
                return content;
            }

            let formattedContent = content;

            for (const token of tokens) {
                try {
                    const infoJson = await parse_token_info(token);
                    const info = JSON.parse(infoJson);

                    // Extract just the hostname from the mint URL
                    let mintDisplay = info.mint;
                    try {
                        const url = new URL(info.mint);
                        mintDisplay = url.hostname;
                    } catch (e) {
                        // If URL parsing fails, use the full string
                    }

                    // Store token for redemption
                    const tokenId = `token-${tokenIdCounter++}`;
                    tokenStore.set(tokenId, token);

                    const tokenHtml = `<span style="background: #ff8800; color: white; padding: 4px 8px; border-radius: 4px; font-weight: bold; display: inline-block; margin: 2px 0;">
                        ${info.amount} sats @ ${mintDisplay}
                        <button onclick="copyToken('${tokenId}', event)" style="background: white; color: #ff8800; border: none; padding: 2px 6px; margin-left: 4px; border-radius: 3px; cursor: pointer; font-weight: bold; font-size: 0.9em;">Copy</button>
                        <button id="${tokenId}" onclick="redeemToken('${tokenId}')" style="background: white; color: #ff8800; border: none; padding: 2px 6px; margin-left: 4px; border-radius: 3px; cursor: pointer; font-weight: bold; font-size: 0.9em;">Redeem</button>
                    </span>`;
                    formattedContent = formattedContent.replace(token, tokenHtml);
                } catch (e) {
                    console.error('Failed to parse token:', e);
                    // Leave the token as-is if parsing fails
                }
            }

            return formattedContent;
        }

        // Copy token to clipboard
        window.copyToken = async function(tokenId, event) {
            const token = tokenStore.get(tokenId);
            if (!token) {
                alert('Token not found');
                return;
            }

            try {
                await navigator.clipboard.writeText(token);
                // Brief visual feedback
                const button = event.target;
                const originalText = button.textContent;
                button.textContent = 'Copied!';
                setTimeout(() => {
                    button.textContent = originalText;
                }, 1500);
            } catch (err) {
                console.error('Failed to copy token:', err);
                alert('Failed to copy token to clipboard');
            }
        };

        // Redemption progress modal functions
        window.showRedemptionProgress = function() {
            document.getElementById('redemption-progress-modal').style.display = 'block';
            document.getElementById('redemption-status').innerHTML = '';
            document.getElementById('redemption-close-btn').style.display = 'none';
        };

        window.hideRedemptionProgress = function() {
            document.getElementById('redemption-progress-modal').style.display = 'none';
        };

        window.redeemToken = async function(tokenId) {
            const token = tokenStore.get(tokenId);
            if (!token) {
                alert('Token not found');
                return;
            }

            const button = document.getElementById(tokenId);
            if (!button) return;

            // Show redemption progress modal
            showRedemptionProgress();
            document.getElementById('redemption-status').innerHTML = 'üîÑ Redeeming token...';

            // Disable button during redemption
            button.disabled = true;
            button.textContent = 'Redeeming...';

            try {
                console.log('üí∞ Redeeming token...');
                const amount = await redeemTokenInternal(token);
                console.log(`‚úÖ Redeemed ${amount} sats!`);

                // Update button to show success
                button.textContent = 'Redeemed ‚úì';
                button.style.background = '#4CAF50';
                button.style.color = 'white';

                // Update wallet balances
                await refreshMintBalances();

                // Remove token from store
                tokenStore.delete(tokenId);

                // Show success in modal
                document.getElementById('redemption-status').innerHTML = `<div class="success" style="font-size: 1.2em;">‚úÖ Successfully redeemed ${amount} sats!</div>`;
                document.getElementById('redemption-close-btn').style.display = 'block';
            } catch (err) {
                console.error('‚ùå Failed to redeem token:', err);
                button.disabled = false;
                button.textContent = 'Redeem';

                if (err.message && err.message.includes('untrusted mint')) {
                    // Close progress modal, untrusted mint warning modal will show
                    hideRedemptionProgress();
                } else {
                    // Show error in modal
                    document.getElementById('redemption-status').innerHTML = `<div class="error" style="font-size: 1.1em;">‚ùå Failed to redeem: ${err}</div>`;
                    document.getElementById('redemption-close-btn').style.display = 'block';
                }
            }
        };

        async function loadMessages(groupId) {
            try {
                // Disable chat input while loading
                setChatInputEnabled(false);

                document.getElementById('chat-messages').innerHTML = '<p style="color: #666;">Loading messages...</p>';

                const messagesJson = await get_messages_for_group(groupId);
                const messages = JSON.parse(messagesJson);

                console.log(`üì¨ Loaded ${messages.length} message(s)`);

                const chatDiv = document.getElementById('chat-messages');
                if (messages.length === 0) {
                    chatDiv.innerHTML = '<p style="color: #666;">No messages yet. Be the first to send one!</p>';
                } else {
                    // Format all messages
                    const formattedMessages = await Promise.all(messages.map(async msg => {
                        const timestamp = new Date(msg.created_at * 1000).toLocaleTimeString();
                        const npub = msg.pubkey.substring(0, 16);
                        const formattedContent = await formatMessageContent(msg.content);

                        // Check if this is the current user's message
                        const isOwnMessage = msg.pubkey === currentUserPubkey;

                        return `
                        <div data-message-id="${msg.id}" style="margin-bottom: 10px; display: flex; justify-content: ${isOwnMessage ? 'flex-end' : 'flex-start'};">
                            <div style="max-width: 70%; padding: 8px; background: ${isOwnMessage ? '#dcf8c6' : 'white'}; border-radius: 8px; ${isOwnMessage ? 'border-bottom-right-radius: 2px;' : 'border-bottom-left-radius: 2px;'}">
                                <div style="font-size: 0.85em; color: #666; margin-bottom: 4px;">
                                    <strong>${npub}...</strong> ‚Ä¢ ${timestamp}
                                </div>
                                <div>${formattedContent}</div>
                            </div>
                        </div>`;
                    }));

                    chatDiv.innerHTML = formattedMessages.join('');
                }

                // Scroll to bottom
                chatDiv.scrollTop = chatDiv.scrollHeight;

                // Re-enable chat input after loading complete
                setChatInputEnabled(true);
            } catch (err) {
                console.error('‚ùå Failed to load messages:', err);
                document.getElementById('chat-messages').innerHTML =
                    `<p style="color: red;">Failed to load messages: ${err}</p>`;

                // Re-enable chat input even on error
                setChatInputEnabled(true);
            }
        }

        async function addMessageToChat(message) {
            const chatDiv = document.getElementById('chat-messages');

            // Check if message already exists (deduplicate)
            if (chatDiv.querySelector(`[data-message-id="${message.id}"]`)) {
                console.log(`Message ${message.id} already exists, skipping`);
                return;
            }

            // Remove "no messages" text if present
            if (chatDiv.querySelector('p')) {
                chatDiv.innerHTML = '';
            }

            const timestamp = new Date(message.created_at * 1000).toLocaleTimeString();
            const npub = message.pubkey.substring(0, 16);
            const formattedContent = await formatMessageContent(message.content);

            // Check if this is the current user's message
            const isOwnMessage = message.pubkey === currentUserPubkey;

            const messageHtml = `
            <div data-message-id="${message.id}" style="margin-bottom: 10px; display: flex; justify-content: ${isOwnMessage ? 'flex-end' : 'flex-start'};">
                <div style="max-width: 70%; padding: 8px; background: ${isOwnMessage ? '#dcf8c6' : 'white'}; border-radius: 8px; ${isOwnMessage ? 'border-bottom-right-radius: 2px;' : 'border-bottom-left-radius: 2px;'}">
                    <div style="font-size: 0.85em; color: #666; margin-bottom: 4px;">
                        <strong>${npub}...</strong> ‚Ä¢ ${timestamp}
                    </div>
                    <div>${formattedContent}</div>
                </div>
            </div>`;

            chatDiv.innerHTML += messageHtml;

            // Scroll to bottom
            chatDiv.scrollTop = chatDiv.scrollHeight;
        }

        // Helper functions to enable/disable chat input
        function setChatInputEnabled(enabled) {
            const input = document.getElementById('chat-input');
            const button = document.getElementById('send-button');

            if (input && button) {
                if (enabled) {
                    input.removeAttribute('data-disabled');
                    input.style.opacity = '1';
                    input.style.cursor = 'text';
                    input.style.backgroundColor = '';
                    button.disabled = false;
                    button.style.opacity = '1';
                    button.style.cursor = 'pointer';
                } else {
                    // Don't use disabled=true to keep focus and prevent Quick Find
                    input.setAttribute('data-disabled', 'true');
                    input.style.opacity = '0.5';
                    input.style.cursor = 'not-allowed';
                    input.style.backgroundColor = '#f5f5f5';
                    button.disabled = true;
                    button.style.opacity = '0.5';
                    button.style.cursor = 'not-allowed';
                }
            }
        }

        window.sendChatMessage = async function() {
            const input = document.getElementById('chat-input');

            // Check if input is logically disabled
            if (input.hasAttribute('data-disabled')) {
                return;
            }

            const message = input.value.trim();

            if (!message) {
                return;
            }

            if (!currentChatGroupId) {
                alert('No group selected');
                return;
            }

            try {
                console.log(`üì§ Sending message: "${message}"`);

                // Disable input while sending
                setChatInputEnabled(false);

                await send_message_to_group(currentChatGroupId, message);
                console.log('‚úÖ Message sent');

                // Clear input
                input.value = '';

                // Immediately reload messages to show the sent message
                // (don't wait for subscription, which might have race conditions)
                await loadMessages(currentChatGroupId);

                // Re-enable input
                setChatInputEnabled(true);

                // Keep keyboard visible on mobile by refocusing
                input.focus();
            } catch (err) {
                console.error('‚ùå Failed to send message:', err);
                alert(`Failed to send message: ${err}`);

                // Re-enable input even on error
                setChatInputEnabled(true);
            }
        };

        // Allow Enter key to send message
        window.addEventListener('DOMContentLoaded', () => {
            const chatInput = document.getElementById('chat-input');
            if (chatInput) {
                chatInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter' && !chatInput.hasAttribute('data-disabled')) {
                        sendChatMessage();
                    }
                });

                // Prevent typing when logically disabled (but keep focus to prevent Quick Find)
                chatInput.addEventListener('keydown', (e) => {
                    if (chatInput.hasAttribute('data-disabled')) {
                        // Allow navigation keys, but prevent typing
                        const allowedKeys = ['Tab', 'Escape', 'ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown', 'Home', 'End'];
                        if (!allowedKeys.includes(e.key)) {
                            e.preventDefault();
                        }
                    }
                });
            }
        });

        async function displayNpub() {
            try {
                const npub = get_or_create_keys();
                document.getElementById('npub').textContent = npub;
                document.getElementById('npub-container').style.display = 'block';
            } catch (err) {
                console.error('Failed to get npub:', err);
                document.getElementById('status').innerHTML =
                    `<div class="error">Failed to get keys: ${err}</div>`;
            }
        }

        window.newKeys = async function() {
            try {
                const npub = generate_keys();
                document.getElementById('npub').textContent = npub;
                log("New keys generated: " + npub);
                alert('New keys generated! Previous keys are overwritten.');
            } catch (err) {
                console.error('Failed to generate keys:', err);
                alert('Failed to generate keys: ' + err);
            }
        };

        window.clearKeys = async function() {
            if (confirm('Are you sure you want to clear your keys? This cannot be undone!')) {
                try {
                    clear_keys();
                    document.getElementById('npub-container').style.display = 'none';
                    document.getElementById('status').innerHTML =
                        '<div class="success">Keys cleared. Reload page to generate new keys.</div>';
                } catch (err) {
                    console.error('Failed to clear keys:', err);
                    alert('Failed to clear keys: ' + err);
                }
            }
        };

        // ==========================================
        // KEY PACKAGE MANAGEMENT
        // ==========================================

        // Create a new KeyPackage
        window.createKeyPackage = async function() {
            try {
                console.log("Creating KeyPackage...");
                const resultJson = await create_and_publish_keypackage();
                const result = JSON.parse(resultJson);

                console.log("KeyPackage created:", result);

                // Save to localStorage
                saveCreatedKeyPackage(result.event_id, result.created_at);

                // Refresh list
                await refreshKeyPackageList();

                showToast('‚úÖ KeyPackage created and published!');
            } catch (err) {
                console.error('Failed to create KeyPackage:', err);
                alert(`Failed to create KeyPackage: ${err}`);
            }
        };

        // Refresh the KeyPackage list display
        async function refreshKeyPackageList() {
            const listDiv = document.getElementById('keypackage-list');
            const nudgeDiv = document.getElementById('keypackage-nudge');
            const created = getCreatedKeyPackages();
            const consumed = getConsumedKeyPackages();

            // Sort by created_at descending (newest first)
            created.sort((a, b) => b.created_at - a.created_at);

            // Count available (not consumed)
            const availableCount = created.filter(kp => !consumed[kp.event_id]).length;

            // Show/hide nudges
            if (availableCount === 0) {
                nudgeDiv.style.display = 'block';
                // Also show nudge on Groups page
                const groupsNudge = document.getElementById('groups-keypackage-nudge');
                if (groupsNudge) groupsNudge.style.display = 'block';
            } else {
                nudgeDiv.style.display = 'none';
                const groupsNudge = document.getElementById('groups-keypackage-nudge');
                if (groupsNudge) groupsNudge.style.display = 'none';
            }

            if (created.length === 0) {
                listDiv.innerHTML = '<p style="color: #666; font-style: italic;">No KeyPackages yet</p>';
                return;
            }

            // Get groups to show names for consumed packages
            const groupsJson = await get_groups();
            const groups = JSON.parse(groupsJson);
            const groupMap = {};
            groups.forEach(g => {
                groupMap[g.id] = g.name || 'Unnamed Group';
            });

            listDiv.innerHTML = created.map(kp => {
                const isConsumed = consumed[kp.event_id];
                const date = new Date(kp.created_at * 1000);
                const timeAgo = formatTimeAgo(kp.created_at);

                let statusHtml;
                if (isConsumed) {
                    const groupName = groupMap[isConsumed] || 'Unknown Group';
                    statusHtml = `<div style="color: #28a745; font-size: 0.9em;">‚úÖ Used to join: ${groupName}</div>`;
                } else {
                    statusHtml = `<div style="color: #666; font-size: 0.9em;">üì¶ Available</div>`;
                }

                const eventIdShort = kp.event_id.substring(0, 16) + '...';

                return `
                    <div style="background: #f9f9f9; border: 1px solid #ddd; border-radius: 4px; padding: 15px; margin: 10px 0;">
                        <div style="display: flex; justify-content: space-between; align-items: flex-start;">
                            <div style="flex: 1;">
                                <div style="font-weight: bold; margin-bottom: 4px;">KeyPackage ${eventIdShort}</div>
                                <div style="font-size: 0.85em; color: #666; margin-bottom: 8px;">
                                    Published: ${timeAgo}
                                </div>
                                ${statusHtml}
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
        }

        // Format timestamp as "X minutes ago"
        function formatTimeAgo(timestamp) {
            const now = Math.floor(Date.now() / 1000);
            const diff = now - timestamp;

            if (diff < 60) return 'Just now';
            if (diff < 3600) return `${Math.floor(diff / 60)} minutes ago`;
            if (diff < 86400) return `${Math.floor(diff / 3600)} hours ago`;
            if (diff < 604800) return `${Math.floor(diff / 86400)} days ago`;

            const date = new Date(timestamp * 1000);
            return date.toLocaleDateString();
        }

        // Show toast notification
        function showToast(message) {
            const toast = document.createElement('div');
            toast.textContent = message;
            toast.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: #28a745;
                color: white;
                padding: 15px 25px;
                border-radius: 8px;
                box-shadow: 0 4px 6px rgba(0,0,0,0.2);
                z-index: 10000;
                font-weight: bold;
                animation: slideIn 0.3s ease-out;
            `;
            document.body.appendChild(toast);

            setTimeout(() => {
                toast.style.animation = 'slideOut 0.3s ease-out';
                setTimeout(() => toast.remove(), 300);
            }, 3000);
        }

        // Check for invites (Welcome messages)
        window.checkForInvites = async function() {
            try {
                console.log("üì¨ Checking for invites...");

                    // Get our keys
                    const ourPubkeyHex = get_pubkey_hex();
                    const ourNpub = get_npub();

                    console.log(`  Our npub: ${ourNpub}`);
                    console.log(`  Our pubkey (hex): ${ourPubkeyHex}`);

                    // Get our created KeyPackages
                    const created = getCreatedKeyPackages();
                    const kpEventIds = created.map(kp => kp.event_id);
                    console.log(`  Our KeyPackage event IDs: ${kpEventIds.length}`, kpEventIds);

                    // Get consumed map
                    const consumed = getConsumedKeyPackages();
                    console.log(`  Consumed KeyPackages:`, consumed);

                    // Fetch all Kind 444 (Welcome) events using WASM function
                    const eventsJson = await debug_fetch_welcome_events();
                    const welcomeEvents = JSON.parse(eventsJson);
                    console.log(`  Found ${welcomeEvents.length} total Welcome events on relays`);

                    // Analyze each Welcome
                    for (const event of welcomeEvents) {
                        console.log(`\n  üì© Welcome event: ${event.id.substring(0, 16)}...`);
                        console.log(`     Created: ${new Date(event.created_at * 1000).toISOString()}`);
                        console.log(`     From pubkey: ${event.pubkey.substring(0, 16)}...`);
                        console.log(`     Content length: ${event.content_len} bytes`);

                        // Check p tags (addressed to)
                        const pTags = event.tags.filter(tag => tag.kind === 'p');
                        const addressedToPubkeys = pTags.map(tag => tag.content).filter(Boolean);
                        console.log(`     P tags (addressed to): ${addressedToPubkeys.length}`,
                            addressedToPubkeys.map(p => p.substring(0, 16) + '...'));

                        const isAddressedToUs = addressedToPubkeys.some(p => p === ourPubkeyHex);
                        console.log(`     ‚úì Addressed to us? ${isAddressedToUs ? 'YES' : 'NO'}`);

                        // Check e tags (references KeyPackages)
                        const eTags = event.tags.filter(tag => tag.kind === 'e');
                        const referencedKPs = eTags.map(tag => tag.content).filter(Boolean);
                        console.log(`     E tags (KeyPackage refs): ${referencedKPs.length}`,
                            referencedKPs.map(kp => kp ? kp.substring(0, 16) + '...' : 'null'));

                        // Check if it references our KeyPackages
                        const matchingKP = referencedKPs.find(kp => kpEventIds.includes(kp));
                        if (matchingKP) {
                            console.log(`     ‚úÖ References our KeyPackage: ${matchingKP.substring(0, 16)}...`);

                            // Check if already consumed
                            if (consumed[matchingKP]) {
                                console.log(`     ‚ö†Ô∏è Already consumed! Used for group: ${consumed[matchingKP]}`);
                            } else {
                                console.log(`     ‚ö° NOT YET CONSUMED - processing now...`);

                                // Process the Welcome
                                try {
                                    const resultJson = await process_welcome_event(event.id, matchingKP);
                                    const result = JSON.parse(resultJson);

                                    console.log(`     ‚úÖ Successfully joined group: ${result.group_name}`);

                                    // Mark KeyPackage as consumed
                                    markKeyPackageConsumed(matchingKP, result.group_id);

                                    // Refresh UI
                                    await refreshKeyPackageList();
                                    await refreshGroups();

                                    // Show toast notification
                                    showToast(`üéâ Joined group: ${result.group_name}`);
                                } catch (err) {
                                    const errorStr = String(err);
                                    console.error(`     ‚ùå Failed to process Welcome: ${errorStr}`);

                                    // If it's already processed, mark as consumed to avoid retrying
                                    if (errorStr.includes("already processed") || errorStr.includes("missing welcome")) {
                                        console.log(`     ‚ÑπÔ∏è Marking KeyPackage as consumed (already processed)`);
                                        // We don't know the group_id, so use a placeholder
                                        markKeyPackageConsumed(matchingKP, "unknown_already_joined");
                                        await refreshKeyPackageList();
                                    }
                                }
                            }
                        } else {
                            console.log(`     ‚ùå Does NOT reference any of our KeyPackages`);
                        }
                    }

                console.log("‚úÖ Finished checking for invites\n");

                // Show toast if no new invites found
                const foundNew = welcomeEvents.some(event => {
                    const eTags = event.tags.filter(tag => tag.kind === 'e');
                    const referencedKPs = eTags.map(tag => tag.content).filter(Boolean);
                    const matchingKP = referencedKPs.find(kp => kpEventIds.includes(kp));
                    return matchingKP && !consumed[matchingKP];
                });

                if (!foundNew) {
                    showToast('No new invites found');
                }

            } catch (err) {
                console.error('‚ùå Error checking for invites:', err);
                showToast('‚ùå Error checking for invites');
            }
        };

        // Subscribe to Welcome messages on startup
        async function initializeWelcomeSubscription() {
            try {
                console.log("Initializing Welcome subscription...");
                await subscribe_to_welcome_messages(async (resultJson) => {
                    const result = JSON.parse(resultJson);
                    console.log("üì® Received Welcome:", result);

                    // Mark KeyPackage as consumed
                    markKeyPackageConsumed(result.kp_event_id, result.group_id);

                    // Refresh groups list
                    await refreshGroups();

                    // Refresh KeyPackage list
                    await refreshKeyPackageList();

                    // Show notification
                    showToast(`üì® Joined group: ${result.group_name}`);
                });

                console.log("‚úì Welcome subscription active");
            } catch (err) {
                console.error('Failed to subscribe to Welcomes:', err);
            }
        }

        // Helper function to redeem token with trust checking
        async function redeemTokenInternal(token) {
            // Parse token info
            const infoJson = await parse_token_info(token);
            const info = JSON.parse(infoJson);

            // Check if mint is trusted
            if (!info.is_trusted) {
                // Show warning modal
                document.getElementById('untrusted-mint-url').textContent = info.mint;
                document.getElementById('untrusted-token-amount').textContent = info.amount;
                document.getElementById('untrusted-mint-modal').style.display = 'block';
                pendingTokenRedemption = { mint: info.mint, token };
                throw new Error('Token from untrusted mint - user must confirm');
            }

            // Proceed with redemption
            const amount = await receive_token(token);
            return amount;
        }

        window.showReceiveModal = function() {
            document.getElementById('receive-modal').style.display = 'block';
            document.getElementById('token-input').value = '';
            document.getElementById('receive-status').innerHTML = '';
        };

        window.hideReceiveModal = function() {
            document.getElementById('receive-modal').style.display = 'none';
        };

        window.receiveToken = async function() {
            const tokenInput = document.getElementById('token-input').value.trim();

            if (!tokenInput) {
                document.getElementById('receive-status').innerHTML = '<div class="error">Please paste a token</div>';
                return;
            }

            // Close receive modal and show progress modal
            hideReceiveModal();
            showRedemptionProgress();
            document.getElementById('redemption-status').innerHTML = 'üîÑ Receiving token...';

            try {
                const amount = await redeemTokenInternal(tokenInput);

                // Update balance display
                await refreshMintBalances();

                // Show success in modal
                document.getElementById('redemption-status').innerHTML = `<div class="success" style="font-size: 1.2em;">‚úÖ Successfully received ${amount} sats!</div>`;
                document.getElementById('redemption-close-btn').style.display = 'block';
            } catch (err) {
                console.error('Failed to receive token:', err);
                if (err.message && err.message.includes('untrusted mint')) {
                    // Close progress modal, untrusted mint warning modal will show
                    hideRedemptionProgress();
                } else {
                    // Show error in modal
                    document.getElementById('redemption-status').innerHTML = `<div class="error" style="font-size: 1.1em;">‚ùå Failed to receive: ${err}</div>`;
                    document.getElementById('redemption-close-btn').style.display = 'block';
                }
            }
        };

        // Send modal functions
        window.showSendModal = async function() {
            document.getElementById('send-modal').style.display = 'block';
            document.getElementById('send-amount-input').value = '';
            document.getElementById('send-status').innerHTML = '';

            // Load mints with balances
            await loadSendMintOptions();
        };

        window.hideSendModal = function() {
            document.getElementById('send-modal').style.display = 'none';
        };

        async function loadSendMintOptions() {
            const selectEl = document.getElementById('send-mint-select');

            try {
                const balancesJson = await get_all_mint_balances();
                const balances = JSON.parse(balancesJson);
                const currentMint = await get_current_mint();

                if (balances.length === 0) {
                    selectEl.innerHTML = '<option value="">No mints with balance</option>';
                    return;
                }

                // Build options
                selectEl.innerHTML = balances.map(b => {
                    const selected = b.mint === currentMint ? 'selected' : '';
                    const trustBadge = b.is_trusted ? '' : ' [UNTRUSTED]';
                    return `<option value="${b.mint}" ${selected}>${b.mint}${trustBadge} (${b.balance} sats)</option>`;
                }).join('');
            } catch (err) {
                console.error('Failed to load mints:', err);
                selectEl.innerHTML = '<option value="">Error loading mints</option>';
            }
        }

        window.createSendToken = async function() {
            const amount = parseInt(document.getElementById('send-amount-input').value);
            const selectedMint = document.getElementById('send-mint-select').value;
            const statusDiv = document.getElementById('send-status');

            if (!amount || amount <= 0) {
                statusDiv.innerHTML = '<div class="error">Please enter a valid amount</div>';
                return;
            }

            if (!selectedMint) {
                statusDiv.innerHTML = '<div class="error">Please select a mint</div>';
                return;
            }

            statusDiv.innerHTML = 'Creating token...';

            try {
                // Set selected mint as current
                const originalMint = await get_current_mint();
                await set_current_mint(selectedMint);

                // Create token
                const token = await send_ecash(BigInt(amount));

                // Restore original mint
                await set_current_mint(originalMint);

                // Display token for copying
                statusDiv.innerHTML = `
                    <div class="success">‚úÖ Token created for ${amount} sats!</div>
                    <div style="margin-top: 15px;">
                        <label style="display: block; margin-bottom: 5px; font-weight: bold;">Token (copy this):</label>
                        <textarea readonly rows="6" style="width: 100%; font-family: monospace; padding: 10px; border: 1px solid #ddd; border-radius: 4px; font-size: 0.85em;">${token}</textarea>
                        <button onclick="navigator.clipboard.writeText('${token.replace(/'/g, "\\'")}'); alert('Token copied to clipboard!')" style="margin-top: 10px;">üìã Copy to Clipboard</button>
                    </div>
                `;

                // Update balance display
                await refreshMintBalances();
            } catch (err) {
                console.error('Failed to create token:', err);
                statusDiv.innerHTML = `<div class="error">Failed to create token: ${err}</div>`;
            }
        };

        // Send e-cash in chat modal functions
        window.showSendEcashInChatModal = async function() {
            if (!currentChatGroupId) {
                alert('No chat group selected');
                return;
            }

            document.getElementById('send-ecash-chat-modal').style.display = 'block';
            document.getElementById('send-ecash-chat-amount').value = '';
            document.getElementById('send-ecash-chat-status').innerHTML = '';

            // Load mints with balances
            await loadSendEcashChatMintOptions();
        };

        window.hideSendEcashInChatModal = function() {
            document.getElementById('send-ecash-chat-modal').style.display = 'none';
        };

        async function loadSendEcashChatMintOptions() {
            const selectEl = document.getElementById('send-ecash-chat-mint-select');

            try {
                const balancesJson = await get_all_mint_balances();
                const balances = JSON.parse(balancesJson);
                const currentMint = await get_current_mint();

                if (balances.length === 0) {
                    selectEl.innerHTML = '<option value="">No mints with balance</option>';
                    return;
                }

                // Build options
                selectEl.innerHTML = balances.map(b => {
                    const selected = b.mint === currentMint ? 'selected' : '';
                    const trustBadge = b.is_trusted ? '' : ' [UNTRUSTED]';
                    return `<option value="${b.mint}" ${selected}>${b.mint}${trustBadge} (${b.balance} sats)</option>`;
                }).join('');
            } catch (err) {
                console.error('Failed to load mints:', err);
                selectEl.innerHTML = '<option value="">Error loading mints</option>';
            }
        }

        window.sendEcashToChat = async function() {
            const amount = parseInt(document.getElementById('send-ecash-chat-amount').value);
            const selectedMint = document.getElementById('send-ecash-chat-mint-select').value;
            const statusDiv = document.getElementById('send-ecash-chat-status');

            if (!amount || amount <= 0) {
                statusDiv.innerHTML = '<div class="error">Please enter a valid amount</div>';
                return;
            }

            if (!selectedMint) {
                statusDiv.innerHTML = '<div class="error">Please select a mint</div>';
                return;
            }

            if (!currentChatGroupId) {
                statusDiv.innerHTML = '<div class="error">No chat group selected</div>';
                return;
            }

            statusDiv.innerHTML = 'Creating token...';

            try {
                // Set selected mint as current
                const originalMint = await get_current_mint();
                await set_current_mint(selectedMint);

                // Create token
                const token = await send_ecash(BigInt(amount));

                // Restore original mint
                await set_current_mint(originalMint);

                statusDiv.innerHTML = 'Sending to group...';

                // Send token as message to group
                await send_message_to_group(currentChatGroupId, token);

                // Update balance display
                await refreshMintBalances();

                // Close modal
                hideSendEcashInChatModal();

                // Reload messages to show the sent token
                await loadMessages(currentChatGroupId);
            } catch (err) {
                console.error('Failed to send e-cash to chat:', err);
                statusDiv.innerHTML = `<div class="error">Failed to send: ${err}</div>`;
            }
        };

        // Intercept console.log to show relay status
        const originalLog = console.log;
        let relayStatusCapture = false;

        console.log = function(...args) {
            originalLog.apply(console, args);

            if (relayStatusCapture && args.length > 0) {
                const message = args[0].toString();

                // Check for relay accept/reject messages
                if (message.includes('‚úì') && message.includes('accepted')) {
                    const relayList = document.getElementById('wait-relay-list');
                    if (relayList) {
                        document.getElementById('wait-relay-status').style.display = 'block';
                        const relay = message.replace(/^\s+‚úì\s+/, '').replace(' accepted', '');
                        relayList.innerHTML += `<div style="color: green; padding: 2px 0;">‚úì ${relay}</div>`;
                    }
                } else if (message.includes('‚úó') && message.includes('rejected')) {
                    const relayList = document.getElementById('wait-relay-list');
                    if (relayList) {
                        document.getElementById('wait-relay-status').style.display = 'block';
                        const parts = message.replace(/^\s+‚úó\s+/, '').split(' rejected: ');
                        const relay = parts[0];
                        const error = parts[1] || 'unknown error';
                        relayList.innerHTML += `<div style="color: #ff6600; padding: 2px 0;">‚úó ${relay}: ${error}</div>`;
                    }
                }
            }
        };

        window.createKeyPackageAndWait = async function() {
            try {
                // Reset and show modal
                document.getElementById('wait-invite-modal').style.display = 'block';
                document.getElementById('wait-npub').textContent = get_npub();
                document.getElementById('wait-status').textContent = 'Creating KeyPackage...';
                document.getElementById('wait-relay-list').innerHTML = '';
                document.getElementById('wait-relay-status').style.display = 'none';

                // Start capturing relay status
                relayStatusCapture = true;

                // Call the WASM function (it will poll and wait)
                const groupName = await create_keypackage_and_wait_for_invite();

                // Stop capturing
                relayStatusCapture = false;

                // Success!
                document.getElementById('wait-status').innerHTML = `<div class="success">‚úÖ Joined group: ${groupName}</div>`;

                // Wait 2 seconds then close modal and refresh groups
                setTimeout(async () => {
                    document.getElementById('wait-invite-modal').style.display = 'none';
                    await refreshGroups(); // Auto-subscribes
                    // Switch to groups tab
                    showSection('groups');
                }, 2000);
            } catch (err) {
                console.error('Failed to join group:', err);
                relayStatusCapture = false;
                document.getElementById('wait-status').innerHTML = `<div class="error">Failed: ${err}</div>`;
                setTimeout(() => {
                    document.getElementById('wait-invite-modal').style.display = 'none';
                }, 3000);
            }
        };

        // Create Group Modal
        window.showCreateGroupModal = function() {
            document.getElementById('create-group-modal').style.display = 'block';
            document.getElementById('create-group-name').value = '';
            document.getElementById('create-group-description').value = '';
            document.getElementById('create-group-first-member').value = '';
            document.getElementById('create-group-status').innerHTML = '';
        };

        window.closeCreateGroupModal = function() {
            document.getElementById('create-group-modal').style.display = 'none';
        };

        window.createGroup = async function() {
            const name = document.getElementById('create-group-name').value.trim();
            const description = document.getElementById('create-group-description').value.trim();
            const firstMember = document.getElementById('create-group-first-member').value.trim();

            if (!name) {
                alert('Please enter a group name');
                return;
            }

            if (!firstMember) {
                alert('Please enter at least one member to invite');
                return;
            }

            if (!firstMember.startsWith('npub1')) {
                alert('Invalid npub format. Must start with npub1');
                return;
            }

            const statusDiv = document.getElementById('create-group-status');
            statusDiv.textContent = 'Creating group...';

            try {
                console.log(`Creating group "${name}" with first member: ${firstMember.substring(0, 16)}...`);

                // Call WASM function with first member
                const groupId = await create_group_with_members(name, description, JSON.stringify([firstMember]));

                statusDiv.innerHTML = `<div class="success">‚úÖ Group created!<br><small>Use "Invite Member" to add more people.</small></div>`;

                // Wait a moment then close and refresh
                setTimeout(async () => {
                    closeCreateGroupModal();
                    await refreshGroups(); // Auto-subscribes
                    showSection('groups');
                }, 2000);
            } catch (err) {
                console.error('Failed to create group:', err);
                statusDiv.innerHTML = `<div class="error">Failed: ${err}</div>`;
            }
        };

        // Invite Member Modal
        let currentGroupIdForInvite = null;

        window.showInviteModal = function() {
            // Store the current group ID
            currentGroupIdForInvite = currentChatGroupId;
            document.getElementById('invite-member-modal').style.display = 'block';
            document.getElementById('invite-member-npub').value = '';
            document.getElementById('invite-member-status').innerHTML = '';
        };

        window.closeInviteModal = function() {
            document.getElementById('invite-member-modal').style.display = 'none';
            currentGroupIdForInvite = null;
        };

        window.inviteMember = async function() {
            const npub = document.getElementById('invite-member-npub').value.trim();

            if (!npub) {
                alert('Please enter an npub');
                return;
            }

            if (!npub.startsWith('npub1')) {
                alert('Invalid npub format. Must start with npub1');
                return;
            }

            if (!currentGroupIdForInvite) {
                alert('No group selected');
                return;
            }

            const statusDiv = document.getElementById('invite-member-status');
            statusDiv.textContent = 'Sending invite...';

            try {
                // Call WASM function
                await invite_member_to_group(currentGroupIdForInvite, npub);

                statusDiv.innerHTML = `<div class="success">‚úÖ Invite sent!</div>`;

                // Wait a moment then close
                setTimeout(() => {
                    closeInviteModal();
                }, 1500);
            } catch (err) {
                console.error('Failed to invite member:', err);
                statusDiv.innerHTML = `<div class="error">Failed: ${err}</div>`;
            }
        };

        // Relay management functions
        window.loadRelays = async function() {
            try {
                const relaysJson = await get_relays();
                const relays = JSON.parse(relaysJson);

                const listDiv = document.getElementById('relays-list');
                if (relays.length === 0) {
                    listDiv.innerHTML = '<p style="color: #666;">No relays configured.</p>';
                    return;
                }

                listDiv.innerHTML = relays.map(relay => `
                    <div style="display: flex; justify-content: space-between; align-items: center; padding: 10px; background: #f5f5f5; margin: 5px 0; border-radius: 4px;">
                        <code style="flex: 1;">${relay}</code>
                        <button onclick="removeRelay('${relay}')" style="background: #999; color: white; padding: 5px 10px; font-size: 0.9em; border: none; border-radius: 4px; cursor: pointer;">Remove</button>
                    </div>
                `).join('');
            } catch (err) {
                console.error('Failed to load relays:', err);
                document.getElementById('relays-list').innerHTML = '<div class="error">Failed to load relays</div>';
            }
        };

        window.addRelay = async function() {
            const input = document.getElementById('relay-input');
            const url = input.value.trim();
            const statusDiv = document.getElementById('relay-add-status');

            if (!url) {
                statusDiv.innerHTML = '<div class="error">Please enter a relay URL</div>';
                return;
            }

            if (!url.startsWith('ws://') && !url.startsWith('wss://')) {
                statusDiv.innerHTML = '<div class="error">Relay URL must start with ws:// or wss://</div>';
                return;
            }

            statusDiv.innerHTML = '<p style="color: #666;">Testing connection...</p>';

            try {
                await add_relay(url);
                statusDiv.innerHTML = '<div class="success">‚úÖ Relay added successfully!</div>';
                input.value = 'wss://';
                await loadRelays();

                setTimeout(() => {
                    statusDiv.innerHTML = '';
                }, 3000);
            } catch (err) {
                console.error('Failed to add relay:', err);
                statusDiv.innerHTML = `<div class="error">Failed: ${err}</div>`;
            }
        };

        window.removeRelay = async function(url) {
            if (!confirm(`Remove relay: ${url}?`)) {
                return;
            }

            try {
                await remove_relay(url);
                await loadRelays();
            } catch (err) {
                console.error('Failed to remove relay:', err);
                alert(`Failed to remove relay: ${err}`);
            }
        };

        // Load WASM on page load
        loadWasm();
    </script>
</body>
</html>
