<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MDK Ecash Web Client</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: Arial, sans-serif;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        #header {
            background: #0066cc;
            color: white;
            padding: 15px 20px;
            font-size: 1.2em;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        #menu-toggle {
            display: none;
            background: none;
            border: none;
            color: white;
            font-size: 1.5em;
            cursor: pointer;
            padding: 5px 10px;
            margin: 0;
        }
        #main {
            display: flex;
            flex: 1;
            overflow: hidden;
        }
        #sidebar {
            width: 250px;
            background: #f5f5f5;
            border-right: 1px solid #ddd;
            overflow-y: auto;
        }
        .nav-item {
            padding: 15px 20px;
            cursor: pointer;
            border-bottom: 1px solid #ddd;
            transition: background 0.2s;
        }
        .nav-item:hover {
            background: #e6e6e6;
        }
        .nav-item.active {
            background: white;
            border-left: 3px solid #0066cc;
            padding-left: 17px;
        }
        #content {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
        }
        .section {
            display: none;
        }
        .section.active {
            display: block;
        }
        .npub {
            font-family: monospace;
            background: #f5f5f5;
            padding: 10px;
            border-radius: 4px;
            word-break: break-all;
            margin: 10px 0;
        }
        button {
            background: #0066cc;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px 5px 5px 0;
        }
        button:hover {
            background: #0052a3;
        }
        .error {
            color: red;
            padding: 10px;
            background: #ffe6e6;
            border-radius: 4px;
            margin: 10px 0;
        }
        .success {
            color: green;
            padding: 10px;
            background: #e6ffe6;
            border-radius: 4px;
            margin: 10px 0;
        }
        .group-item {
            padding: 12px;
            background: #f5f5f5;
            margin: 8px 0;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s;
            min-height: 80px;
        }
        .group-item:hover {
            background: #e6e6e6;
        }
        .group-item.active {
            background: #0066cc;
            color: white;
        }

        /* Mobile Responsive Styles */
        @media (max-width: 768px) {
            #menu-toggle {
                display: block;
            }

            #sidebar {
                position: fixed;
                left: -250px;
                top: 0;
                bottom: 0;
                width: 250px;
                z-index: 1000;
                transition: left 0.3s ease;
                box-shadow: 2px 0 5px rgba(0,0,0,0.3);
            }

            #sidebar.open {
                left: 0;
            }

            #content {
                padding: 10px;
            }

            /* Larger touch targets */
            button {
                min-height: 44px;
                font-size: 1em;
            }

            .nav-item {
                padding: 18px 20px;
                font-size: 1.1em;
            }

            .group-item {
                padding: 15px;
                font-size: 1em;
            }

            /* Chat area */
            #chat-messages {
                height: 50vh !important;
            }

            #chat-input {
                font-size: 16px !important; /* Prevents zoom on iOS */
            }

            /* Header adjustments */
            #header {
                padding: 12px 15px;
                font-size: 1.1em;
            }

            /* Modal adjustments */
            #create-group-modal > div,
            #invite-member-modal > div,
            #receive-modal > div,
            #qr-modal > div {
                margin: 20px;
                max-width: none !important;
                border-radius: 8px;
            }

            /* Reduce font sizes slightly */
            h2 {
                font-size: 1.3em;
            }

            /* Chat header buttons */
            #chat-section > div:first-child {
                flex-direction: column;
                align-items: stretch !important;
                gap: 10px;
            }

            #chat-section > div:first-child > div {
                flex-direction: column;
                width: 100%;
            }

            #chat-section > div:first-child button {
                width: 100%;
            }

            /* Input fields larger for touch */
            input[type="text"],
            textarea {
                font-size: 16px !important;
                padding: 12px !important;
            }
        }

        /* Overlay for sidebar on mobile */
        #sidebar-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            z-index: 999;
        }

        #sidebar-overlay.active {
            display: block;
        }
    </style>
</head>
<body>
    <div id="header">
        <button id="menu-toggle" onclick="toggleSidebar()">‚ò∞</button>
        <span>üîê MDK Ecash Web Client</span>
        <span></span> <!-- Spacer for flex layout -->
    </div>
    <div id="sidebar-overlay" onclick="closeSidebar()"></div>

    <div id="main">
        <!-- Sidebar -->
        <div id="sidebar">
            <div class="nav-item active" onclick="showSection('identity', event)">üîê Nostr Identity</div>
            <div class="nav-item" onclick="showSection('relays', event)">‚öôÔ∏è Relays</div>
            <div class="nav-item" onclick="showSection('wallet', event)">üí∞ Wallet</div>
            <div class="nav-item" onclick="showSection('keypackages', event)">üîë Key Packages</div>
            <div class="nav-item" onclick="showSection('groups', event)">üì± Groups</div>
        </div>

        <!-- Content Area -->
        <div id="content">
            <!-- Identity Section -->
            <div id="identity-section" class="section active">
                <h2>Nostr Identity</h2>
                <div id="status">Loading WASM module...</div>
                <div id="npub-container" style="display: none;">
                    <p><strong>Your npub:</strong></p>
                    <div class="npub" id="npub"></div>
                </div>
                <div id="buttons" style="display: none;">
                    <button onclick="newKeys()">Generate New Keys</button>
                    <button onclick="clearKeys()">Clear Keys</button>
                </div>
            </div>

            <!-- Wallet Section -->
            <div id="wallet-section" class="section">
                <h2>üí∞ Wallet</h2>
                <p>Mint: <code>https://nofees.testnut.cashu.space</code></p>
                <p style="margin-top: 10px;">Balance: <strong><span id="balance">0</span> sats</strong></p>
                <div id="wallet-status">Initializing wallet...</div>
                <button onclick="showReceiveModal()">Receive e-cash</button>
            </div>

            <!-- Key Packages Section -->
            <div id="keypackages-section" class="section">
                <h2>üîë Join a Group</h2>
                <p>Click the button below to create a KeyPackage and wait for someone to invite you to a group.</p>
                <button onclick="createKeyPackageAndWait()">üöÄ Create KeyPackage & Wait for Invite</button>
                <div id="keypackages-status" style="margin-top: 20px;"></div>
            </div>

            <!-- Groups Section -->
            <div id="groups-section" class="section">
                <h2>üì± Groups</h2>
                <div id="groups-status">Loading groups...</div>
                <div id="groups-list"></div>
                <button onclick="showCreateGroupModal()">‚ûï Create New Group</button>
            </div>

            <!-- Chat Section -->
            <div id="chat-section" class="section" style="display: none;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                    <h2 id="chat-group-name">üí¨ Chat</h2>
                    <div style="display: flex; gap: 10px;">
                        <button id="invite-member-btn" onclick="showInviteModal()">‚ûï Invite Member</button>
                        <button onclick="closeChat()">‚Üê Back to Groups</button>
                    </div>
                </div>
                <div id="chat-messages" style="height: 400px; overflow-y: auto; border: 1px solid #ccc; padding: 10px; margin-bottom: 10px; background: #f9f9f9;">
                    <p style="color: #666;">Loading messages...</p>
                </div>
                <div style="display: flex; gap: 10px;">
                    <input type="text" id="chat-input" placeholder="Type a message..." style="flex: 1; padding: 10px; border: 1px solid #ccc; border-radius: 4px;">
                    <button id="send-button" onclick="sendChatMessage()" style="padding: 10px 20px;">Send</button>
                </div>
            </div>

            <!-- Relays Section -->
            <div id="relays-section" class="section">
                <h2>‚öôÔ∏è Relays</h2>
                <p>Configure which Nostr relays to use for group messaging.</p>

                <h3 style="margin-top: 20px;">Current Relays</h3>
                <div id="relays-list" style="margin: 10px 0;">
                    <p style="color: #666;">Loading relays...</p>
                </div>

                <h3 style="margin-top: 20px;">Add New Relay</h3>
                <div style="display: flex; gap: 10px; margin-top: 10px;">
                    <input type="text" id="relay-input" value="wss://" placeholder="wss://relay.example.com" style="flex: 1; padding: 10px; border: 1px solid #ccc; border-radius: 4px;">
                    <button onclick="addRelay()">‚ûï Add Relay</button>
                </div>
                <div id="relay-add-status" style="margin-top: 10px;"></div>
            </div>
        </div>
    </div>

    <!-- Receive Modal -->
    <div id="receive-modal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); z-index: 1000;">
        <div style="background: white; max-width: 600px; margin: 50px auto; padding: 20px; border-radius: 8px;">
            <h2>Receive e-cash Token</h2>
            <p>Paste your Cashu token below:</p>
            <textarea id="token-input" rows="6" style="width: 100%; font-family: monospace; padding: 10px; border: 1px solid #ddd; border-radius: 4px;"></textarea>
            <div style="margin-top: 10px;">
                <button onclick="receiveToken()">Receive</button>
                <button onclick="hideReceiveModal()">Cancel</button>
            </div>
            <div id="receive-status" style="margin-top: 10px;"></div>
        </div>
    </div>

    <!-- Wait for Invite Modal -->
    <div id="wait-invite-modal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); z-index: 1000; overflow-y: auto;">
        <div style="background: white; max-width: 700px; margin: 50px auto; padding: 30px; border-radius: 8px; text-align: center;">
            <h2>‚è≥ Waiting for Group Invite</h2>
            <p style="margin: 20px 0;">Your KeyPackage is being published!</p>
            <div class="npub" id="wait-npub" style="margin: 20px 0;"></div>
            <div id="wait-status" style="margin: 20px 0; font-weight: bold; color: #0066cc;"></div>

            <!-- Relay Status -->
            <div id="wait-relay-status" style="margin: 20px auto; max-width: 500px; text-align: left; font-size: 0.9em; max-height: 200px; overflow-y: auto; background: #f9f9f9; padding: 10px; border-radius: 4px; display: none;">
                <div style="font-weight: bold; margin-bottom: 5px; text-align: center;">Relay Status:</div>
                <div id="wait-relay-list"></div>
            </div>

            <p style="color: #666; margin: 20px 0;" id="wait-instruction">Waiting for someone to invite you to a group...</p>
            <div style="margin-top: 20px;">
                <div style="display: inline-block; width: 40px; height: 40px; border: 4px solid #f3f3f3; border-top: 4px solid #0066cc; border-radius: 50%; animation: spin 1s linear infinite;"></div>
            </div>
        </div>
    </div>

    <!-- Create Group Modal -->
    <div id="create-group-modal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); z-index: 1000;">
        <div style="background: white; max-width: 500px; margin: 100px auto; padding: 30px; border-radius: 8px;">
            <h2>‚ûï Create New Group</h2>
            <div style="margin: 20px 0;">
                <label style="display: block; margin-bottom: 5px; font-weight: bold;">Group Name:</label>
                <input type="text" id="create-group-name" placeholder="My Group" style="width: 100%; padding: 10px; border: 1px solid #ccc; border-radius: 4px;">
            </div>
            <div style="margin: 20px 0;">
                <label style="display: block; margin-bottom: 5px; font-weight: bold;">Description (optional):</label>
                <textarea id="create-group-description" placeholder="What's this group about?" style="width: 100%; padding: 10px; border: 1px solid #ccc; border-radius: 4px; min-height: 60px;"></textarea>
            </div>
            <div style="margin: 20px 0;">
                <label style="display: block; margin-bottom: 5px; font-weight: bold;">First member to invite:</label>
                <input type="text" id="create-group-first-member" placeholder="npub1..." style="width: 100%; padding: 10px; border: 1px solid #ccc; border-radius: 4px; font-family: monospace; font-size: 0.9em;">
                <p style="font-size: 0.9em; color: #666; margin-top: 5px;">Groups require you and at least 1 other member. You can invite more people later.</p>
            </div>
            <div id="create-group-status" style="margin: 20px 0; color: #0066cc;"></div>
            <div style="display: flex; gap: 10px; margin-top: 20px;">
                <button onclick="createGroup()" style="flex: 1; padding: 12px; background: #0066cc; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 1em;">Create Group</button>
                <button onclick="closeCreateGroupModal()" style="padding: 12px 30px; background: #ccc; border: none; border-radius: 4px; cursor: pointer;">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Invite Member Modal -->
    <div id="invite-member-modal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); z-index: 1000;">
        <div style="background: white; max-width: 500px; margin: 100px auto; padding: 30px; border-radius: 8px;">
            <h2>‚ûï Invite Member to Group</h2>
            <div style="margin: 20px 0;">
                <label style="display: block; margin-bottom: 5px; font-weight: bold;">Member's npub:</label>
                <input type="text" id="invite-member-npub" placeholder="npub1abc..." style="width: 100%; padding: 10px; border: 1px solid #ccc; border-radius: 4px; font-family: monospace; font-size: 0.9em;">
                <p style="font-size: 0.9em; color: #666; margin-top: 5px;">Enter the npub of the person you want to invite</p>
            </div>
            <div id="invite-member-status" style="margin: 20px 0; color: #0066cc;"></div>
            <div style="display: flex; gap: 10px; margin-top: 20px;">
                <button onclick="inviteMember()" style="flex: 1; padding: 12px; background: #0066cc; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 1em;">Send Invite</button>
                <button onclick="closeInviteModal()" style="padding: 12px 30px; background: #ccc; border: none; border-radius: 4px; cursor: pointer;">Cancel</button>
            </div>
        </div>
    </div>

    <style>
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>

    <script type="module">
        // ==========================================
        // TAB LOCK MECHANISM
        // ==========================================
        const LOCK_KEY = 'mdk_tab_lock';
        const LOCK_HEARTBEAT_INTERVAL = 2000; // 2 seconds
        const LOCK_STALE_TIMEOUT = 5000; // 5 seconds

        let hasLock = false;
        let heartbeatInterval = null;
        let lockCheckInterval = null;

        function acquireLock() {
            const now = Date.now();
            const lockData = localStorage.getItem(LOCK_KEY);

            if (lockData) {
                try {
                    const lock = JSON.parse(lockData);
                    const age = now - lock.timestamp;

                    // If lock is fresh (< 5 sec), another tab owns it
                    if (age < LOCK_STALE_TIMEOUT) {
                        return false;
                    }
                    // Lock is stale, we can take it
                    console.log('Lock was stale, taking over');
                } catch (e) {
                    console.error('Failed to parse lock data:', e);
                }
            }

            // Acquire the lock
            const lockInfo = {
                timestamp: now,
                tabId: Math.random().toString(36).substring(7)
            };
            localStorage.setItem(LOCK_KEY, JSON.stringify(lockInfo));
            hasLock = true;
            console.log('üîí Lock acquired');
            return true;
        }

        function updateHeartbeat() {
            if (!hasLock) return;

            const now = Date.now();
            const lockInfo = {
                timestamp: now,
                tabId: 'current'
            };
            localStorage.setItem(LOCK_KEY, JSON.stringify(lockInfo));
        }

        function releaseLock() {
            if (hasLock) {
                localStorage.removeItem(LOCK_KEY);
                hasLock = false;
                console.log('üîì Lock released');
            }
        }

        function showLockWarning() {
            document.body.innerHTML = `
                <div style="display: flex; align-items: center; justify-content: center; height: 100vh; background: #f5f5f5; font-family: Arial, sans-serif;">
                    <div style="text-align: center; padding: 40px; max-width: 600px; background: white; border-radius: 12px; box-shadow: 0 2px 10px rgba(0,0,0,0.1);">
                        <div style="font-size: 4em; margin-bottom: 20px;">üëã</div>
                        <h2 style="color: #333; margin-bottom: 20px; font-weight: normal;">Already open in another tab</h2>
                        <p style="font-size: 1.1em; color: #666; margin-bottom: 20px; line-height: 1.6;">
                            You've already got this app running somewhere else. To keep your wallet and messages safe,
                            please use that tab instead.
                        </p>
                        <p style="font-size: 0.95em; color: #888; margin-top: 30px; line-height: 1.6;">
                            If you closed the other tab, just wait a moment and <a href="#" onclick="location.reload()" style="color: #0066cc; text-decoration: none; border-bottom: 1px solid #0066cc;">click here to reload</a>.
                        </p>
                    </div>
                </div>
            `;
        }

        // Try to acquire lock on load
        if (!acquireLock()) {
            showLockWarning();
            throw new Error('Cannot start - app already open in another tab');
        }

        // Send heartbeats
        heartbeatInterval = setInterval(updateHeartbeat, LOCK_HEARTBEAT_INTERVAL);

        // Release lock on unload
        window.addEventListener('beforeunload', () => {
            releaseLock();
        });

        // Listen for storage events (another tab released lock)
        window.addEventListener('storage', (e) => {
            if (e.key === LOCK_KEY) {
                if (!hasLock) {
                    // We don't have lock, check if we can acquire it now
                    if (e.newValue === null || e.newValue === '') {
                        // Lock was released, try to acquire
                        setTimeout(() => {
                            if (acquireLock()) {
                                location.reload();
                            }
                        }, 100);
                    }
                }
            }
        });

        // Periodically check if we still have the lock
        lockCheckInterval = setInterval(() => {
            if (hasLock) {
                const lockData = localStorage.getItem(LOCK_KEY);
                if (!lockData) {
                    console.error('Lock was lost!');
                    hasLock = false;
                    showLockWarning();
                    clearInterval(heartbeatInterval);
                    clearInterval(lockCheckInterval);
                }
            }
        }, 1000);

        // ==========================================
        // END TAB LOCK MECHANISM
        // ==========================================

        import init, {
            get_or_create_keys,
            generate_keys,
            get_npub,
            clear_keys,
            init_wallet,
            get_balance,
            receive_token,
            parse_token_info,
            get_groups,
            fetch_welcome_events,
            process_pending_welcomes,
            create_keypackage_and_wait_for_invite,
            create_group_with_members,
            invite_member_to_group,
            send_message_to_group,
            get_messages_for_group,
            subscribe_to_group_messages,
            get_relays,
            add_relay,
            remove_relay,
            log
        } from './pkg/mdk_ecash_web.js';

        let wasm;

        // Unread message tracking
        function getLastReadAt(groupId) {
            const key = `last_read_at_${groupId}`;
            const value = localStorage.getItem(key);
            return value ? parseInt(value) : 0;
        }

        function setLastReadAt(groupId, timestamp) {
            const key = `last_read_at_${groupId}`;
            localStorage.setItem(key, timestamp.toString());
        }

        function countUnreadMessages(groupId, messages, lastReadAt) {
            return messages.filter(msg => msg.created_at > lastReadAt).length;
        }

        // Mobile sidebar toggle
        window.toggleSidebar = function() {
            const sidebar = document.getElementById('sidebar');
            const overlay = document.getElementById('sidebar-overlay');
            sidebar.classList.toggle('open');
            overlay.classList.toggle('active');
        };

        window.closeSidebar = function() {
            const sidebar = document.getElementById('sidebar');
            const overlay = document.getElementById('sidebar-overlay');
            sidebar.classList.remove('open');
            overlay.classList.remove('active');
        };

        // Swipe to close sidebar on mobile
        let touchStartX = 0;
        let touchStartY = 0;
        let touchEndX = 0;
        let touchEndY = 0;

        window.addEventListener('DOMContentLoaded', () => {
            const sidebar = document.getElementById('sidebar');

            sidebar.addEventListener('touchstart', (e) => {
                touchStartX = e.changedTouches[0].screenX;
                touchStartY = e.changedTouches[0].screenY;
            });

            sidebar.addEventListener('touchend', (e) => {
                touchEndX = e.changedTouches[0].screenX;
                touchEndY = e.changedTouches[0].screenY;
                handleSwipe();
            });

            function handleSwipe() {
                const diffX = touchStartX - touchEndX;
                const diffY = touchStartY - touchEndY;

                // Only detect horizontal swipes (more horizontal than vertical)
                if (Math.abs(diffX) > Math.abs(diffY)) {
                    // Swipe left (to close) - need at least 50px movement
                    // diffX > 0 means swiped left (start was right of end)
                    if (diffX > 50) {
                        closeSidebar();
                    }
                }
            }
        });

        // Navigation
        window.showSection = function(sectionName, event, skipHashUpdate = false) {
            // Close sidebar on mobile when navigating
            closeSidebar();
            // Hide all sections
            document.querySelectorAll('.section').forEach(s => s.classList.remove('active'));
            document.querySelectorAll('.nav-item').forEach(n => n.classList.remove('active'));

            // Also hide chat section (uses inline display style)
            document.getElementById('chat-section').style.display = 'none';

            // Show selected section
            document.getElementById(`${sectionName}-section`).classList.add('active');

            // Mark the nav item as active (if called from nav click)
            if (event && event.target) {
                event.target.classList.add('active');
            } else {
                // Called programmatically, find and activate the nav item
                const navItem = Array.from(document.querySelectorAll('.nav-item'))
                    .find(item => item.getAttribute('onclick')?.includes(`'${sectionName}'`));
                if (navItem) {
                    navItem.classList.add('active');
                }
            }

            // Load content if needed
            if (sectionName === 'groups') {
                refreshGroups();
            } else if (sectionName === 'relays') {
                loadRelays();
            }

            // Update URL hash (unless we're restoring from hash)
            if (!skipHashUpdate) {
                window.location.hash = sectionName;
            }
        };

        async function loadWasm() {
            try {
                wasm = await init();
                log("WASM module loaded successfully");
                await displayNpub();
                await initializeWallet();
                await initializeGroups();
                document.getElementById('buttons').style.display = 'block';
                document.getElementById('status').innerHTML = '<div class="success">‚úì Ready</div>';

                // Restore state from URL hash
                await restoreFromHash();
            } catch (err) {
                console.error('Failed to load WASM:', err);
                document.getElementById('status').innerHTML =
                    `<div class="error">Failed to load WASM: ${err}</div>`;
            }
        }

        // Restore state from URL hash
        async function restoreFromHash() {
            const hash = window.location.hash.slice(1); // Remove leading #
            if (!hash) return;

            if (hash.startsWith('chat:')) {
                // Format: chat:groupId:groupName
                const parts = hash.split(':');
                if (parts.length >= 3) {
                    const groupId = parts[1];
                    const groupName = decodeURIComponent(parts.slice(2).join(':'));

                    // Fetch groups to get admin status
                    try {
                        const groupsJson = await get_groups();
                        const groups = JSON.parse(groupsJson);
                        const group = groups.find(g => g.id === groupId);
                        const isAdmin = group ? group.is_admin : false;

                        await openChat(groupId, groupName, isAdmin, true); // isAdmin, skipHashUpdate=true
                    } catch (err) {
                        console.error('Failed to fetch admin status:', err);
                        await openChat(groupId, groupName, false, true); // Default to non-admin
                    }
                }
            } else {
                // Regular section like 'wallet', 'groups', etc.
                if (document.getElementById(`${hash}-section`)) {
                    showSection(hash, null, true); // skipHashUpdate=true
                }
            }
        }

        // Listen for hash changes (browser back/forward)
        window.addEventListener('hashchange', async () => {
            await restoreFromHash();
        });

        async function initializeWallet() {
            try {
                document.getElementById('wallet-status').textContent = 'Initializing wallet...';

                const balance = await init_wallet();
                document.getElementById('balance').textContent = balance;
                document.getElementById('wallet-status').innerHTML = '<div class="success">‚úì Wallet ready</div>';
                log("Wallet initialized with balance: " + balance);
            } catch (err) {
                console.error('Failed to initialize wallet:', err);
                document.getElementById('wallet-status').innerHTML =
                    `<div class="error">Failed to initialize wallet: ${err}</div>`;
            }
        }

        // Track which groups we've already subscribed to
        const subscribedGroups = new Set();

        async function subscribeToAllGroups() {
            try {
                const groupsJson = await get_groups();
                const groups = JSON.parse(groupsJson);

                for (const group of groups) {
                    // Skip if already subscribed
                    if (subscribedGroups.has(group.id)) {
                        continue;
                    }

                    console.log(`üì° Subscribing to group: ${group.name} (${group.id.substring(0, 16)}...)`);

                    // Subscribe and mark as subscribed
                    await subscribe_to_group_messages(group.id, async (message) => {
                        console.log(`üì® Message in ${group.name}:`, message);

                        // If this group's chat is currently open, add the message
                        if (currentChatGroupId === group.id) {
                            await addMessageToChat(message);
                        }

                        // Refresh groups list to update "Last activity" timestamp
                        // Pass false to skip re-subscribing (we're already subscribed)
                        await refreshGroups(false);
                    });

                    subscribedGroups.add(group.id);
                    console.log(`‚úÖ Subscribed to group: ${group.name}`);
                }
            } catch (err) {
                console.error('Failed to subscribe to groups:', err);
            }
        }

        async function initializeGroups() {
            // Disable chat input during initial load
            setChatInputEnabled(false);
            await refreshGroups(); // Now auto-subscribes
            // Note: chat input will be re-enabled when openChat() -> loadMessages() completes
        }

        window.refreshGroups = async function(autoSubscribe = true) {
            try {
                console.log('üîÑ Refreshing groups list...');
                document.getElementById('groups-status').textContent = 'Loading groups...';

                const groupsJson = await get_groups();
                console.log('  Received groups JSON:', groupsJson);
                const groups = JSON.parse(groupsJson);
                console.log(`  Parsed ${groups.length} group(s)`);

                const listDiv = document.getElementById('groups-list');
                if (groups.length === 0) {
                    listDiv.innerHTML = '<p style="color: #666;">No groups yet. Accept an invite to get started!</p>';
                    document.getElementById('groups-status').innerHTML = '<div class="success">‚úì Ready (0 groups)</div>';
                } else {
                    // Sort by most recent activity (last_message_at), most recent first
                    groups.sort((a, b) => {
                        const aTime = a.last_message_at || 0;
                        const bTime = b.last_message_at || 0;
                        return bTime - aTime; // Descending order (newest first)
                    });

                    // Fetch last message for each group to show preview and count unread
                    const groupsWithPreviews = await Promise.all(groups.map(async (group) => {
                        let messagePreview = '';
                        let unreadCount = 0;

                        // Check if group has any messages (using last_message_at instead of last_message_id)
                        console.log(`Fetching preview for group ${group.name}, has last_message_at: ${!!group.last_message_at}`);
                        if (group.last_message_at) {
                            try {
                                const messagesJson = await get_messages_for_group(group.id);
                                const messages = JSON.parse(messagesJson);
                                console.log(`  Group ${group.name} has ${messages.length} messages`);

                                // Count unread messages
                                const lastReadAt = getLastReadAt(group.id);
                                unreadCount = countUnreadMessages(group.id, messages, lastReadAt);
                                console.log(`  Group ${group.name} has ${unreadCount} unread messages (last read: ${lastReadAt})`);

                                if (messages.length > 0) {
                                    // Get the last message (most recent)
                                    const lastMsg = messages[messages.length - 1];
                                    const content = lastMsg.content || '';
                                    console.log(`  Last message content: "${content}"`);
                                    // Truncate to 50 chars and strip any special commands
                                    const truncated = content.length > 50 ? content.substring(0, 50) + '...' : content;
                                    messagePreview = truncated;
                                    console.log(`  Preview set to: "${messagePreview}"`);
                                }
                            } catch (err) {
                                console.error('Failed to fetch message preview:', err);
                            }
                        }
                        return { ...group, messagePreview, unreadCount };
                    }));

                    listDiv.innerHTML = groupsWithPreviews.map(group => {
                        console.log(`  Rendering group: ${group.name || 'Unnamed'} (ID: ${group.id})`);
                        const memberCount = group.member_count || 0;
                        const adminBadge = group.is_admin ? '<span style="color: #ffa500; font-size: 0.8em; margin-left: 5px;">üëë Admin</span>' : '';
                        const preview = group.messagePreview
                            ? `<div style="color: #888; font-size: 0.9em; margin-top: 4px; font-style: italic;">${group.messagePreview}</div>`
                            : '';

                        // Unread badge and timestamp
                        const hasUnread = group.unreadCount > 0;
                        const unreadBadge = hasUnread
                            ? `<span style="background: #0066cc; color: white; border-radius: 12px; padding: 3px 10px; font-size: 0.85em; font-weight: bold; margin-right: 8px; display: inline-block;">${group.unreadCount}</span>`
                            : '';

                        // Extra bold group name if unread (900 weight)
                        const groupNameStyle = hasUnread ? 'font-weight: 900;' : '';

                        // Format timestamp with badge to the left of date/time
                        let timestampHtml = '';
                        if (group.last_message_at) {
                            const date = new Date(group.last_message_at * 1000);
                            const dateStr = date.toLocaleDateString('en-CA'); // YYYY-MM-DD format
                            const timeStr = date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                            timestampHtml = `
                                <div style="display: flex; align-items: center; gap: 8px;">
                                    ${unreadBadge}
                                    <div style="text-align: right; color: #999; font-size: 0.85em; line-height: 1.3;">
                                        <div>${dateStr}</div>
                                        <div>${timeStr}</div>
                                    </div>
                                </div>`;
                        } else if (hasUnread) {
                            // If no timestamp but has unread, just show badge
                            timestampHtml = `<div>${unreadBadge}</div>`;
                        }

                        console.log(`  Rendering group ${group.name}: messagePreview="${group.messagePreview}", unreadCount=${group.unreadCount}`);
                        return `
                        <div class="group-item" onclick="openChat('${group.id}', '${(group.name || 'Unnamed Group').replace(/'/g, "\\'")}', ${group.is_admin})" style="cursor: pointer; padding: 15px; border-bottom: 1px solid #eee; transition: background 0.2s; display: flex; justify-content: space-between; align-items: flex-start;" onmouseover="this.style.background='#f5f5f5'" onmouseout="this.style.background='white'">
                            <div style="flex: 1; min-width: 0;">
                                <strong style="font-size: 1.1em; ${groupNameStyle}">${group.name || 'Unnamed Group'}</strong>${adminBadge}
                                <span style="color: #666; font-size: 0.9em; margin-left: 10px;">üë• ${memberCount} member${memberCount !== 1 ? 's' : ''}</span>
                                <br>
                                <small style="color: #666;">${group.description || 'No description'}</small>${preview}
                            </div>
                            ${timestampHtml}
                        </div>`;
                    }).join('');
                    document.getElementById('groups-status').innerHTML =
                        `<div class="success">‚úì Found ${groups.length} group(s)</div>`;
                }

                console.log(`‚úÖ Groups list refreshed (${groups.length} group(s))`);
                log(`Loaded ${groups.length} group(s)`);

                // Auto-subscribe to any new groups
                if (autoSubscribe) {
                    await subscribeToAllGroups();
                }
            } catch (err) {
                console.error('‚ùå Failed to fetch groups:', err);
                document.getElementById('groups-status').innerHTML =
                    `<div class="error">Failed to load: ${err}</div>`;
            }
        };

        window.processWelcomes = async function() {
            const statusDiv = document.getElementById('groups-status');
            statusDiv.innerHTML = 'Checking for new group invites...';

            try {
                // Step 1: Fetch Welcome events from Nostr relays
                statusDiv.innerHTML = 'Fetching invites from Nostr relays...';
                const fetched = await fetch_welcome_events();
                log(`Fetched and processed ${fetched} Welcome event(s)`);

                // Step 2: Auto-accept any pending welcomes
                statusDiv.innerHTML = 'Processing invites...';
                const count = await process_pending_welcomes();

                if (count > 0) {
                    statusDiv.innerHTML = `<div class="success">‚úÖ Joined ${count} new group(s)!</div>`;
                    // Refresh groups list and auto-subscribe to new groups
                    await refreshGroups();
                } else {
                    statusDiv.innerHTML = '<div class="success">No new invites found</div>';
                }
            } catch (err) {
                console.error('Failed to process welcomes:', err);
                statusDiv.innerHTML = `<div class="error">Failed to process invites: ${err}</div>`;
            }
        };

        // Chat interface variables
        let currentChatGroupId = null;
        let currentChatGroupName = null;
        let currentUserIsAdmin = false;

        window.openChat = async function(groupId, groupName, isAdmin = false, skipHashUpdate = false) {
            console.log(`üí¨ Opening chat for group: ${groupName} (${groupId}), isAdmin: ${isAdmin}`);

            // Close sidebar on mobile
            closeSidebar();

            // Mark as read (current timestamp)
            setLastReadAt(groupId, Math.floor(Date.now() / 1000));

            // Store current group info
            currentChatGroupId = groupId;
            currentChatGroupName = groupName;
            currentUserIsAdmin = isAdmin;

            // Update invite button state based on admin status
            const inviteBtn = document.getElementById('invite-member-btn');
            if (isAdmin) {
                inviteBtn.disabled = false;
                inviteBtn.style.opacity = '1';
                inviteBtn.style.cursor = 'pointer';
                inviteBtn.title = '';
            } else {
                inviteBtn.disabled = true;
                inviteBtn.style.opacity = '0.5';
                inviteBtn.style.cursor = 'not-allowed';
                inviteBtn.title = 'Only admins can invite members';
            }

            // Hide all sections
            document.querySelectorAll('.section').forEach(s => s.classList.remove('active'));

            // Update UI and show chat
            document.getElementById('chat-group-name').textContent = `üí¨ ${groupName}`;
            document.getElementById('chat-section').style.display = 'block';

            // Update URL hash (encode groupName to handle special characters) unless we're restoring from hash
            if (!skipHashUpdate) {
                window.location.hash = `chat:${groupId}:${encodeURIComponent(groupName)}`;
            }

            // Load messages
            await loadMessages(groupId);

            // Note: Subscription already active from startup (subscribeToAllGroups)
        };

        window.closeChat = function() {
            console.log('‚Üê Closing chat');
            currentChatGroupId = null;
            currentChatGroupName = null;
            showSection('groups');
        };

        // Store tokens by ID for redemption
        const tokenStore = new Map();
        let tokenIdCounter = 0;

        // Format message content, detecting and formatting Cashu tokens
        async function formatMessageContent(content) {
            // Detect cashu tokens (start with cashuA or cashuB)
            const tokenRegex = /cashu[AB][A-Za-z0-9_-]+/g;
            const tokens = content.match(tokenRegex);

            if (!tokens) {
                return content;
            }

            let formattedContent = content;

            for (const token of tokens) {
                try {
                    const infoJson = await parse_token_info(token);
                    const info = JSON.parse(infoJson);

                    // Extract just the hostname from the mint URL
                    let mintDisplay = info.mint;
                    try {
                        const url = new URL(info.mint);
                        mintDisplay = url.hostname;
                    } catch (e) {
                        // If URL parsing fails, use the full string
                    }

                    // Store token for redemption
                    const tokenId = `token-${tokenIdCounter++}`;
                    tokenStore.set(tokenId, token);

                    const tokenHtml = `<span style="background: #ff8800; color: white; padding: 4px 8px; border-radius: 4px; font-weight: bold; display: inline-block; margin: 2px 0;">
                        ${info.amount} sats @ ${mintDisplay}
                        <button id="${tokenId}" onclick="redeemToken('${tokenId}')" style="background: white; color: #ff8800; border: none; padding: 2px 6px; margin-left: 4px; border-radius: 3px; cursor: pointer; font-weight: bold; font-size: 0.9em;">Redeem</button>
                    </span>`;
                    formattedContent = formattedContent.replace(token, tokenHtml);
                } catch (e) {
                    console.error('Failed to parse token:', e);
                    // Leave the token as-is if parsing fails
                }
            }

            return formattedContent;
        }

        window.redeemToken = async function(tokenId) {
            const token = tokenStore.get(tokenId);
            if (!token) {
                alert('Token not found');
                return;
            }

            const button = document.getElementById(tokenId);
            if (!button) return;

            // Disable button during redemption
            button.disabled = true;
            button.textContent = 'Redeeming...';

            try {
                console.log('üí∞ Redeeming token...');
                const amount = await receive_token(token);
                console.log(`‚úÖ Redeemed ${amount} sats!`);

                // Update button to show success
                button.textContent = 'Redeemed ‚úì';
                button.style.background = '#4CAF50';
                button.style.color = 'white';

                // Update wallet balance
                const newBalance = await get_balance();
                document.getElementById('balance').textContent = newBalance;

                // Remove token from store
                tokenStore.delete(tokenId);

                alert(`Successfully redeemed ${amount} sats!`);
            } catch (err) {
                console.error('‚ùå Failed to redeem token:', err);
                button.disabled = false;
                button.textContent = 'Redeem';
                alert(`Failed to redeem token: ${err}`);
            }
        };

        async function loadMessages(groupId) {
            try {
                // Disable chat input while loading
                setChatInputEnabled(false);

                document.getElementById('chat-messages').innerHTML = '<p style="color: #666;">Loading messages...</p>';

                const messagesJson = await get_messages_for_group(groupId);
                const messages = JSON.parse(messagesJson);

                console.log(`üì¨ Loaded ${messages.length} message(s)`);

                const chatDiv = document.getElementById('chat-messages');
                if (messages.length === 0) {
                    chatDiv.innerHTML = '<p style="color: #666;">No messages yet. Be the first to send one!</p>';
                } else {
                    // Format all messages
                    const formattedMessages = await Promise.all(messages.map(async msg => {
                        const timestamp = new Date(msg.created_at * 1000).toLocaleTimeString();
                        const npub = msg.pubkey.substring(0, 16);
                        const formattedContent = await formatMessageContent(msg.content);
                        return `
                        <div data-message-id="${msg.id}" style="margin-bottom: 10px; padding: 8px; background: white; border-radius: 4px;">
                            <div style="font-size: 0.85em; color: #666; margin-bottom: 4px;">
                                <strong>${npub}...</strong> ‚Ä¢ ${timestamp}
                            </div>
                            <div>${formattedContent}</div>
                        </div>`;
                    }));

                    chatDiv.innerHTML = formattedMessages.join('');
                }

                // Scroll to bottom
                chatDiv.scrollTop = chatDiv.scrollHeight;

                // Re-enable chat input after loading complete
                setChatInputEnabled(true);
            } catch (err) {
                console.error('‚ùå Failed to load messages:', err);
                document.getElementById('chat-messages').innerHTML =
                    `<p style="color: red;">Failed to load messages: ${err}</p>`;

                // Re-enable chat input even on error
                setChatInputEnabled(true);
            }
        }

        async function addMessageToChat(message) {
            const chatDiv = document.getElementById('chat-messages');

            // Check if message already exists (deduplicate)
            if (chatDiv.querySelector(`[data-message-id="${message.id}"]`)) {
                console.log(`Message ${message.id} already exists, skipping`);
                return;
            }

            // Remove "no messages" text if present
            if (chatDiv.querySelector('p')) {
                chatDiv.innerHTML = '';
            }

            const timestamp = new Date(message.created_at * 1000).toLocaleTimeString();
            const npub = message.pubkey.substring(0, 16);
            const formattedContent = await formatMessageContent(message.content);

            const messageHtml = `
            <div data-message-id="${message.id}" style="margin-bottom: 10px; padding: 8px; background: white; border-radius: 4px;">
                <div style="font-size: 0.85em; color: #666; margin-bottom: 4px;">
                    <strong>${npub}...</strong> ‚Ä¢ ${timestamp}
                </div>
                <div>${formattedContent}</div>
            </div>`;

            chatDiv.innerHTML += messageHtml;

            // Scroll to bottom
            chatDiv.scrollTop = chatDiv.scrollHeight;
        }

        // Helper functions to enable/disable chat input
        function setChatInputEnabled(enabled) {
            const input = document.getElementById('chat-input');
            const button = document.getElementById('send-button');

            if (input && button) {
                if (enabled) {
                    input.removeAttribute('data-disabled');
                    input.style.opacity = '1';
                    input.style.cursor = 'text';
                    input.style.backgroundColor = '';
                    button.disabled = false;
                    button.style.opacity = '1';
                    button.style.cursor = 'pointer';
                } else {
                    // Don't use disabled=true to keep focus and prevent Quick Find
                    input.setAttribute('data-disabled', 'true');
                    input.style.opacity = '0.5';
                    input.style.cursor = 'not-allowed';
                    input.style.backgroundColor = '#f5f5f5';
                    button.disabled = true;
                    button.style.opacity = '0.5';
                    button.style.cursor = 'not-allowed';
                }
            }
        }

        window.sendChatMessage = async function() {
            const input = document.getElementById('chat-input');

            // Check if input is logically disabled
            if (input.hasAttribute('data-disabled')) {
                return;
            }

            const message = input.value.trim();

            if (!message) {
                return;
            }

            if (!currentChatGroupId) {
                alert('No group selected');
                return;
            }

            try {
                console.log(`üì§ Sending message: "${message}"`);

                // Disable input while sending
                setChatInputEnabled(false);

                await send_message_to_group(currentChatGroupId, message);
                console.log('‚úÖ Message sent');

                // Clear input
                input.value = '';

                // Immediately reload messages to show the sent message
                // (don't wait for subscription, which might have race conditions)
                await loadMessages(currentChatGroupId);

                // Re-enable input
                setChatInputEnabled(true);

                // Keep keyboard visible on mobile by refocusing
                input.focus();
            } catch (err) {
                console.error('‚ùå Failed to send message:', err);
                alert(`Failed to send message: ${err}`);

                // Re-enable input even on error
                setChatInputEnabled(true);
            }
        };

        // Allow Enter key to send message
        window.addEventListener('DOMContentLoaded', () => {
            const chatInput = document.getElementById('chat-input');
            if (chatInput) {
                chatInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter' && !chatInput.hasAttribute('data-disabled')) {
                        sendChatMessage();
                    }
                });

                // Prevent typing when logically disabled (but keep focus to prevent Quick Find)
                chatInput.addEventListener('keydown', (e) => {
                    if (chatInput.hasAttribute('data-disabled')) {
                        // Allow navigation keys, but prevent typing
                        const allowedKeys = ['Tab', 'Escape', 'ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown', 'Home', 'End'];
                        if (!allowedKeys.includes(e.key)) {
                            e.preventDefault();
                        }
                    }
                });
            }
        });

        async function displayNpub() {
            try {
                const npub = get_or_create_keys();
                document.getElementById('npub').textContent = npub;
                document.getElementById('npub-container').style.display = 'block';
            } catch (err) {
                console.error('Failed to get npub:', err);
                document.getElementById('status').innerHTML =
                    `<div class="error">Failed to get keys: ${err}</div>`;
            }
        }

        window.newKeys = async function() {
            try {
                const npub = generate_keys();
                document.getElementById('npub').textContent = npub;
                log("New keys generated: " + npub);
                alert('New keys generated! Previous keys are overwritten.');
            } catch (err) {
                console.error('Failed to generate keys:', err);
                alert('Failed to generate keys: ' + err);
            }
        };

        window.clearKeys = async function() {
            if (confirm('Are you sure you want to clear your keys? This cannot be undone!')) {
                try {
                    clear_keys();
                    document.getElementById('npub-container').style.display = 'none';
                    document.getElementById('status').innerHTML =
                        '<div class="success">Keys cleared. Reload page to generate new keys.</div>';
                } catch (err) {
                    console.error('Failed to clear keys:', err);
                    alert('Failed to clear keys: ' + err);
                }
            }
        };

        window.showReceiveModal = function() {
            document.getElementById('receive-modal').style.display = 'block';
            document.getElementById('token-input').value = '';
            document.getElementById('receive-status').innerHTML = '';
        };

        window.hideReceiveModal = function() {
            document.getElementById('receive-modal').style.display = 'none';
        };

        window.receiveToken = async function() {
            const tokenInput = document.getElementById('token-input').value.trim();
            const statusDiv = document.getElementById('receive-status');

            if (!tokenInput) {
                statusDiv.innerHTML = '<div class="error">Please paste a token</div>';
                return;
            }

            statusDiv.innerHTML = 'Receiving token...';

            try {
                const amount = await receive_token(tokenInput);
                statusDiv.innerHTML = `<div class="success">‚úÖ Received ${amount} sats!</div>`;

                // Update balance display
                const newBalance = await get_balance();
                document.getElementById('balance').textContent = newBalance;

                // Close modal after 2 seconds
                setTimeout(() => {
                    hideReceiveModal();
                }, 2000);
            } catch (err) {
                console.error('Failed to receive token:', err);
                statusDiv.innerHTML = `<div class="error">Failed to receive: ${err}</div>`;
            }
        };

        // Intercept console.log to show relay status
        const originalLog = console.log;
        let relayStatusCapture = false;

        console.log = function(...args) {
            originalLog.apply(console, args);

            if (relayStatusCapture && args.length > 0) {
                const message = args[0].toString();

                // Check for relay accept/reject messages
                if (message.includes('‚úì') && message.includes('accepted')) {
                    const relayList = document.getElementById('wait-relay-list');
                    if (relayList) {
                        document.getElementById('wait-relay-status').style.display = 'block';
                        const relay = message.replace(/^\s+‚úì\s+/, '').replace(' accepted', '');
                        relayList.innerHTML += `<div style="color: green; padding: 2px 0;">‚úì ${relay}</div>`;
                    }
                } else if (message.includes('‚úó') && message.includes('rejected')) {
                    const relayList = document.getElementById('wait-relay-list');
                    if (relayList) {
                        document.getElementById('wait-relay-status').style.display = 'block';
                        const parts = message.replace(/^\s+‚úó\s+/, '').split(' rejected: ');
                        const relay = parts[0];
                        const error = parts[1] || 'unknown error';
                        relayList.innerHTML += `<div style="color: #ff6600; padding: 2px 0;">‚úó ${relay}: ${error}</div>`;
                    }
                }
            }
        };

        window.createKeyPackageAndWait = async function() {
            try {
                // Reset and show modal
                document.getElementById('wait-invite-modal').style.display = 'block';
                document.getElementById('wait-npub').textContent = get_npub();
                document.getElementById('wait-status').textContent = 'Creating KeyPackage...';
                document.getElementById('wait-relay-list').innerHTML = '';
                document.getElementById('wait-relay-status').style.display = 'none';

                // Start capturing relay status
                relayStatusCapture = true;

                // Call the WASM function (it will poll and wait)
                const groupName = await create_keypackage_and_wait_for_invite();

                // Stop capturing
                relayStatusCapture = false;

                // Success!
                document.getElementById('wait-status').innerHTML = `<div class="success">‚úÖ Joined group: ${groupName}</div>`;

                // Wait 2 seconds then close modal and refresh groups
                setTimeout(async () => {
                    document.getElementById('wait-invite-modal').style.display = 'none';
                    await refreshGroups(); // Auto-subscribes
                    // Switch to groups tab
                    showSection('groups');
                }, 2000);
            } catch (err) {
                console.error('Failed to join group:', err);
                relayStatusCapture = false;
                document.getElementById('wait-status').innerHTML = `<div class="error">Failed: ${err}</div>`;
                setTimeout(() => {
                    document.getElementById('wait-invite-modal').style.display = 'none';
                }, 3000);
            }
        };

        // Create Group Modal
        window.showCreateGroupModal = function() {
            document.getElementById('create-group-modal').style.display = 'block';
            document.getElementById('create-group-name').value = '';
            document.getElementById('create-group-description').value = '';
            document.getElementById('create-group-first-member').value = '';
            document.getElementById('create-group-status').innerHTML = '';
        };

        window.closeCreateGroupModal = function() {
            document.getElementById('create-group-modal').style.display = 'none';
        };

        window.createGroup = async function() {
            const name = document.getElementById('create-group-name').value.trim();
            const description = document.getElementById('create-group-description').value.trim();
            const firstMember = document.getElementById('create-group-first-member').value.trim();

            if (!name) {
                alert('Please enter a group name');
                return;
            }

            if (!firstMember) {
                alert('Please enter at least one member to invite');
                return;
            }

            if (!firstMember.startsWith('npub1')) {
                alert('Invalid npub format. Must start with npub1');
                return;
            }

            const statusDiv = document.getElementById('create-group-status');
            statusDiv.textContent = 'Creating group...';

            try {
                console.log(`Creating group "${name}" with first member: ${firstMember.substring(0, 16)}...`);

                // Call WASM function with first member
                const groupId = await create_group_with_members(name, description, JSON.stringify([firstMember]));

                statusDiv.innerHTML = `<div class="success">‚úÖ Group created!<br><small>Use "Invite Member" to add more people.</small></div>`;

                // Wait a moment then close and refresh
                setTimeout(async () => {
                    closeCreateGroupModal();
                    await refreshGroups(); // Auto-subscribes
                    showSection('groups');
                }, 2000);
            } catch (err) {
                console.error('Failed to create group:', err);
                statusDiv.innerHTML = `<div class="error">Failed: ${err}</div>`;
            }
        };

        // Invite Member Modal
        let currentGroupIdForInvite = null;

        window.showInviteModal = function() {
            // Store the current group ID
            currentGroupIdForInvite = currentChatGroupId;
            document.getElementById('invite-member-modal').style.display = 'block';
            document.getElementById('invite-member-npub').value = '';
            document.getElementById('invite-member-status').innerHTML = '';
        };

        window.closeInviteModal = function() {
            document.getElementById('invite-member-modal').style.display = 'none';
            currentGroupIdForInvite = null;
        };

        window.inviteMember = async function() {
            const npub = document.getElementById('invite-member-npub').value.trim();

            if (!npub) {
                alert('Please enter an npub');
                return;
            }

            if (!npub.startsWith('npub1')) {
                alert('Invalid npub format. Must start with npub1');
                return;
            }

            if (!currentGroupIdForInvite) {
                alert('No group selected');
                return;
            }

            const statusDiv = document.getElementById('invite-member-status');
            statusDiv.textContent = 'Sending invite...';

            try {
                // Call WASM function
                await invite_member_to_group(currentGroupIdForInvite, npub);

                statusDiv.innerHTML = `<div class="success">‚úÖ Invite sent!</div>`;

                // Wait a moment then close
                setTimeout(() => {
                    closeInviteModal();
                }, 1500);
            } catch (err) {
                console.error('Failed to invite member:', err);
                statusDiv.innerHTML = `<div class="error">Failed: ${err}</div>`;
            }
        };

        // Relay management functions
        window.loadRelays = async function() {
            try {
                const relaysJson = await get_relays();
                const relays = JSON.parse(relaysJson);

                const listDiv = document.getElementById('relays-list');
                if (relays.length === 0) {
                    listDiv.innerHTML = '<p style="color: #666;">No relays configured.</p>';
                    return;
                }

                listDiv.innerHTML = relays.map(relay => `
                    <div style="display: flex; justify-content: space-between; align-items: center; padding: 10px; background: #f5f5f5; margin: 5px 0; border-radius: 4px;">
                        <code style="flex: 1;">${relay}</code>
                        <button onclick="removeRelay('${relay}')" style="background: #999; color: white; padding: 5px 10px; font-size: 0.9em; border: none; border-radius: 4px; cursor: pointer;">Remove</button>
                    </div>
                `).join('');
            } catch (err) {
                console.error('Failed to load relays:', err);
                document.getElementById('relays-list').innerHTML = '<div class="error">Failed to load relays</div>';
            }
        };

        window.addRelay = async function() {
            const input = document.getElementById('relay-input');
            const url = input.value.trim();
            const statusDiv = document.getElementById('relay-add-status');

            if (!url) {
                statusDiv.innerHTML = '<div class="error">Please enter a relay URL</div>';
                return;
            }

            if (!url.startsWith('ws://') && !url.startsWith('wss://')) {
                statusDiv.innerHTML = '<div class="error">Relay URL must start with ws:// or wss://</div>';
                return;
            }

            statusDiv.innerHTML = '<p style="color: #666;">Testing connection...</p>';

            try {
                await add_relay(url);
                statusDiv.innerHTML = '<div class="success">‚úÖ Relay added successfully!</div>';
                input.value = 'wss://';
                await loadRelays();

                setTimeout(() => {
                    statusDiv.innerHTML = '';
                }, 3000);
            } catch (err) {
                console.error('Failed to add relay:', err);
                statusDiv.innerHTML = `<div class="error">Failed: ${err}</div>`;
            }
        };

        window.removeRelay = async function(url) {
            if (!confirm(`Remove relay: ${url}?`)) {
                return;
            }

            try {
                await remove_relay(url);
                await loadRelays();
            } catch (err) {
                console.error('Failed to remove relay:', err);
                alert(`Failed to remove relay: ${err}`);
            }
        };

        // Load WASM on page load
        loadWasm();
    </script>
</body>
</html>
